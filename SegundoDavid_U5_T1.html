<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>segundodavid_u5_t1 – Reportes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-8ef56b68f8fa1e9d2ba328e99e439f80.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-cc63fce9873912f1bbbccf05079cc9ea.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-08799928d293638fe9563d5c5a2794e5.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="site_libs/bootstrap/bootstrap-cc63fce9873912f1bbbccf05079cc9ea.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Reportes</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.qmd"> 
<span class="menu-text">Inicio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./SegundoDavid_U1_T1.html"> 
<span class="menu-text">Unidad 1</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./SegundoDavid_U2_T1.html"> 
<span class="menu-text">Unidad 2</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./SegundoDavid_U3_T1.html"> 
<span class="menu-text">Unidad 3</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./SegundoDavid_U4_T1.html"> 
<span class="menu-text">Unidad 4</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./SegundoDavid_U5_T1.html" aria-current="page"> 
<span class="menu-text">Unidad 5</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./cambios.html"> 
<span class="menu-text">Cambios</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">En esta página</h2>
   
  <ul>
  <li><a href="#introducción" id="toc-introducción" class="nav-link active" data-scroll-target="#introducción"><strong>Introducción</strong></a>
  <ul class="collapse">
  <li><a href="#metodología-de-evaluación" id="toc-metodología-de-evaluación" class="nav-link" data-scroll-target="#metodología-de-evaluación"><strong>Metodología de Evaluación</strong></a></li>
  </ul></li>
  <li><a href="#instrucciones" id="toc-instrucciones" class="nav-link" data-scroll-target="#instrucciones"><strong>Instrucciones</strong></a>
  <ul class="collapse">
  <li><a href="#definimos-las-librerías-que-usaremos" id="toc-definimos-las-librerías-que-usaremos" class="nav-link" data-scroll-target="#definimos-las-librerías-que-usaremos"><strong>Definimos las librerías que usaremos:</strong></a></li>
  <li><a href="#carga-de-archivos-para-iniciar-procesamiento" id="toc-carga-de-archivos-para-iniciar-procesamiento" class="nav-link" data-scroll-target="#carga-de-archivos-para-iniciar-procesamiento"><strong>Carga de archivos para iniciar procesamiento</strong></a></li>
  </ul></li>
  <li><a href="#implementación-y-descripción-técnica-de-los-algoritmos" id="toc-implementación-y-descripción-técnica-de-los-algoritmos" class="nav-link" data-scroll-target="#implementación-y-descripción-técnica-de-los-algoritmos"><strong>Implementación y Descripción Técnica de los Algoritmos</strong></a>
  <ul class="collapse">
  <li><a href="#algoritmos-de-búsqueda" id="toc-algoritmos-de-búsqueda" class="nav-link" data-scroll-target="#algoritmos-de-búsqueda"><strong>Algoritmos de búsqueda</strong></a>
  <ul class="collapse">
  <li><a href="#función-de-búsqueda-binaria" id="toc-función-de-búsqueda-binaria" class="nav-link" data-scroll-target="#función-de-búsqueda-binaria"><strong>Función de búsqueda binaria</strong></a></li>
  <li><a href="#dobling-search-b1" id="toc-dobling-search-b1" class="nav-link" data-scroll-target="#dobling-search-b1"><strong>Dobling search (B1)</strong></a></li>
  <li><a href="#búsqueda-b2-doble-doubling" id="toc-búsqueda-b2-doble-doubling" class="nav-link" data-scroll-target="#búsqueda-b2-doble-doubling"><strong>Búsqueda B2 (doble doubling)</strong></a></li>
  </ul></li>
  <li><a href="#algoritmos-de-intersección" id="toc-algoritmos-de-intersección" class="nav-link" data-scroll-target="#algoritmos-de-intersección"><strong>Algoritmos de intersección</strong></a>
  <ul class="collapse">
  <li><a href="#melding-intersection-me" id="toc-melding-intersection-me" class="nav-link" data-scroll-target="#melding-intersection-me"><strong>Melding Intersection (ME)</strong></a></li>
  <li><a href="#baeza-yates" id="toc-baeza-yates" class="nav-link" data-scroll-target="#baeza-yates"><strong>Baeza-Yates</strong></a></li>
  <li><a href="#baeza-yates-con-búsqueda-exponencial" id="toc-baeza-yates-con-búsqueda-exponencial" class="nav-link" data-scroll-target="#baeza-yates-con-búsqueda-exponencial"><strong>Baeza-Yates con búsqueda exponencial</strong></a></li>
  <li><a href="#baeza-yates-con-búsqueda-exponencial-b2" id="toc-baeza-yates-con-búsqueda-exponencial-b2" class="nav-link" data-scroll-target="#baeza-yates-con-búsqueda-exponencial-b2"><strong>Baeza-Yates con búsqueda exponencial (B2)</strong></a></li>
  <li><a href="#barbay-kenyon-bk" id="toc-barbay-kenyon-bk" class="nav-link" data-scroll-target="#barbay-kenyon-bk"><strong>Barbay &amp; Kenyon (BK)</strong></a></li>
  </ul></li>
  </ul></li>
  <li><a href="#desarrollo-del-experimento" id="toc-desarrollo-del-experimento" class="nav-link" data-scroll-target="#desarrollo-del-experimento"><strong>Desarrollo del Experimento</strong></a>
  <ul class="collapse">
  <li><a href="#conversión-de-resultados-a-formato-tabular" id="toc-conversión-de-resultados-a-formato-tabular" class="nav-link" data-scroll-target="#conversión-de-resultados-a-formato-tabular"><strong>Conversión de Resultados a Formato Tabular</strong></a></li>
  <li><a href="#boxplot-de-tiempos-de-ejecución-por-algoritmo-y-conjunto" id="toc-boxplot-de-tiempos-de-ejecución-por-algoritmo-y-conjunto" class="nav-link" data-scroll-target="#boxplot-de-tiempos-de-ejecución-por-algoritmo-y-conjunto"><strong>Boxplot de Tiempos de Ejecución por Algoritmo y Conjunto</strong></a>
  <ul class="collapse">
  <li><a href="#análisis-de-tiempos-de-ejecución" id="toc-análisis-de-tiempos-de-ejecución" class="nav-link" data-scroll-target="#análisis-de-tiempos-de-ejecución"><strong>Análisis de Tiempos de Ejecución</strong></a></li>
  <li><a href="#conjunto-a" id="toc-conjunto-a" class="nav-link" data-scroll-target="#conjunto-a">Conjunto A</a></li>
  <li><a href="#conjunto-b" id="toc-conjunto-b" class="nav-link" data-scroll-target="#conjunto-b">Conjunto B</a></li>
  <li><a href="#conjunto-c" id="toc-conjunto-c" class="nav-link" data-scroll-target="#conjunto-c">Conjunto C</a></li>
  <li><a href="#observaciones-generales" id="toc-observaciones-generales" class="nav-link" data-scroll-target="#observaciones-generales">Observaciones Generales</a></li>
  </ul></li>
  <li><a href="#boxplot-del-número-de-comparaciones-por-algoritmo-y-conjunto" id="toc-boxplot-del-número-de-comparaciones-por-algoritmo-y-conjunto" class="nav-link" data-scroll-target="#boxplot-del-número-de-comparaciones-por-algoritmo-y-conjunto"><strong>Boxplot del Número de Comparaciones por Algoritmo y Conjunto</strong></a>
  <ul class="collapse">
  <li><a href="#análisis-de-comparaciones" id="toc-análisis-de-comparaciones" class="nav-link" data-scroll-target="#análisis-de-comparaciones"><strong>Análisis de Comparaciones</strong></a></li>
  <li><a href="#conjunto-a-1" id="toc-conjunto-a-1" class="nav-link" data-scroll-target="#conjunto-a-1">Conjunto A</a></li>
  <li><a href="#conjunto-b-1" id="toc-conjunto-b-1" class="nav-link" data-scroll-target="#conjunto-b-1">Conjunto B</a></li>
  <li><a href="#conjunto-c-1" id="toc-conjunto-c-1" class="nav-link" data-scroll-target="#conjunto-c-1">Conjunto C</a></li>
  <li><a href="#observaciones-generales-1" id="toc-observaciones-generales-1" class="nav-link" data-scroll-target="#observaciones-generales-1">Observaciones Generales</a></li>
  </ul></li>
  <li><a href="#boxplot-de-longitudes-de-intersección-como-métrica-de-control" id="toc-boxplot-de-longitudes-de-intersección-como-métrica-de-control" class="nav-link" data-scroll-target="#boxplot-de-longitudes-de-intersección-como-métrica-de-control"><strong>Boxplot de Longitudes de Intersección como Métrica de Control</strong></a>
  <ul class="collapse">
  <li><a href="#análisis-de-longitudes-de-intersección" id="toc-análisis-de-longitudes-de-intersección" class="nav-link" data-scroll-target="#análisis-de-longitudes-de-intersección"><strong>Análisis de Longitudes de Intersección</strong></a></li>
  <li><a href="#conjunto-a-2" id="toc-conjunto-a-2" class="nav-link" data-scroll-target="#conjunto-a-2">Conjunto A</a></li>
  <li><a href="#conjunto-b-2" id="toc-conjunto-b-2" class="nav-link" data-scroll-target="#conjunto-b-2">Conjunto B</a></li>
  <li><a href="#conjunto-c-2" id="toc-conjunto-c-2" class="nav-link" data-scroll-target="#conjunto-c-2">Conjunto C</a></li>
  </ul></li>
  <li><a href="#observaciones-generales-2" id="toc-observaciones-generales-2" class="nav-link" data-scroll-target="#observaciones-generales-2">Observaciones Generales</a></li>
  </ul></li>
  <li><a href="#conclusiones-generales" id="toc-conclusiones-generales" class="nav-link" data-scroll-target="#conclusiones-generales"><strong>Conclusiones Generales</strong></a>
  <ul class="collapse">
  <li><a href="#gráficos" id="toc-gráficos" class="nav-link" data-scroll-target="#gráficos">Gráficos</a></li>
  <li><a href="#tabla-y-métricas" id="toc-tabla-y-métricas" class="nav-link" data-scroll-target="#tabla-y-métricas">Tabla y Métricas</a></li>
  <li><a href="#síntesis-final" id="toc-síntesis-final" class="nav-link" data-scroll-target="#síntesis-final">Síntesis Final</a></li>
  </ul></li>
  <li><a href="#referencias" id="toc-referencias" class="nav-link" data-scroll-target="#referencias"><strong>Referencias</strong></a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>





<h1>
<b>Práctica: Algoritmos de intersección y unión de conjuntos en el modelo de comparación</b>
</h1>
<h1>
<b>Alumno: David Segundo Garcia</b>
</h1>
<hr>
<section id="introducción" class="level1">
<h1><strong>Introducción</strong></h1>
<p><strong>Análisis Comparativo de Algoritmos de Intersección de Conjuntos</strong></p>
<p>Este estudio evalúa y compara el desempeño de varios algoritmos diseñados para resolver el problema de la intersección de conjuntos ordenados, un problema fundamental en estructuras como los índices invertidos y sistemas de recuperación de información (Hwang &amp; Lin, 1971). En dichos contextos, los conjuntos se representan frecuentemente como listas ordenadas de enteros, lo cual permite aplicar algoritmos especializados de búsqueda y comparación.</p>
<p>Se implementaron y analizaron las siguientes estrategias algorítmicas:</p>
<ul>
<li><p><strong>Melding (ME)</strong>: basado en el escaneo secuencial de punteros para conjuntos ordenados.</p></li>
<li><p><strong>Baeza-Yates (BY)</strong> con variantes de búsqueda interna:</p>
<ul>
<li><strong>Bisección (BY_bis)</strong>: búsqueda binaria clásica.</li>
<li><strong>Búsqueda exponencial (BY_B1)</strong>: óptima cuando los tamaños de los conjuntos son muy distintos.</li>
<li><strong>Búsqueda doblemente exponencial (BY_B2)</strong>: adaptativa, eficiente al aprovechar información previa.</li>
</ul></li>
<li><p><strong>Barbay &amp; Kenyon (BK)</strong>: enfoque adaptativo que memoriza posiciones previamente exploradas para acelerar búsquedas subsecuentes.</p></li>
</ul>
<p>Estos algoritmos surgen como solución al problema de determinar eficientemente la intersección entre listas ordenadas, minimizando el número de comparaciones y el uso de memoria. En particular, el algoritmo de Baeza-Yates aplica una estrategia de <strong>divide y vencerás</strong> al buscar la mediana del primer conjunto dentro del segundo y dividir el problema en subproblemas más pequeños (Baeza-Yates, 2004). Por otro lado, el algoritmo de Barbay y Kenyon (2006) emplea búsquedas adaptativas para aprovechar concentraciones locales y reducir trabajo redundante. Ambos algoritmos están diseñados para ser óptimos incluso en el peor caso.</p>
<p>Además, se consideran técnicas como <strong>merge</strong> (fusión secuencial) para listas de tamaño similar, y estrategias como <strong>Small vs Small (SvS)</strong> para intersecciones entre múltiples conjuntos, que consisten en intersectar los subconjuntos más pequeños primero, obteniendo así ganancias de eficiencia (Demaine et al., 2001).</p>
<hr>
<section id="metodología-de-evaluación" class="level3">
<h3 class="anchored" data-anchor-id="metodología-de-evaluación"><strong>Metodología de Evaluación</strong></h3>
<p>Los algoritmos fueron evaluados experimentalmente sobre tres tipos de conjuntos:</p>
<ul>
<li><strong>Conjunto A</strong>: pares de listas ordenadas.</li>
<li><strong>Conjunto B</strong>: tripletas de listas ordenadas.</li>
<li><strong>Conjunto C</strong>: tetrapletas (cuádruples) de listas ordenadas.</li>
</ul>
<p>Para cada algoritmo y conjunto se midieron tres métricas clave:</p>
<ul>
<li><strong>Tiempo de ejecución</strong> (en segundos)</li>
<li><strong>Número de comparaciones realizadas</strong> (costo en el modelo de comparación)</li>
<li><strong>Tamaño de la intersección resultante</strong> (control de consistencia)</li>
</ul>
<p>Estos resultados permiten contrastar la <strong>eficiencia algorítmica</strong> bajo distintas configuraciones de entrada, diferenciando entre comportamientos óptimos y degenerados. Además, se tomaron en cuenta los modelos de costo teóricos, como el modelo de comparación, donde el número mínimo de comparaciones requeridas para unir dos conjuntos de tamaños <span class="math inline">\(m\)</span> y <span class="math inline">\(n\)</span> se aproxima por <span class="math inline">\(\log_2\binom{m+n}{m}\)</span> (Hwang &amp; Lin, 1971; MacKay, 2003), y los escenarios donde <span class="math inline">\(m \ll n\)</span>, que justifican el uso de búsquedas binarias para mejorar la eficiencia a <span class="math inline">\(O(m \log n)\)</span>.</p>
<hr>
</section>
</section>
<section id="instrucciones" class="level1">
<h1><strong>Instrucciones</strong></h1>
<ol type="1">
<li><p><strong>Lea</strong> el archivo de datos provisto, el cual se encuentra en formato JSON, y contiene múltiples listas de datos:</p>
<ul>
<li>Conjunto <strong>A</strong> que contiene pares de listas.</li>
<li>Conjunto <strong>B</strong> que contiene tripletas de listas.</li>
<li>Conjunto <strong>C</strong> que contiene tuplas de 4 listas (tetrapleta).</li>
</ul></li>
<li><p><strong>Implementación de Algoritmos</strong>:</p>
<ul>
<li><strong>Implemente</strong> los algoritmos de Melding (ME), Baeza-Yates (BY) y de Barbay &amp; Kenyon (BK).</li>
<li><strong>Implemente</strong> BY parametrizando con algoritmos de búsqueda: bisección, y búsqueda no acotada B1 y B2 (ver Unidad 4).</li>
</ul></li>
<li><p><strong>Experimentación</strong>:</p>
<ul>
<li><p><strong>Calcule</strong> las intersecciones para los datos de cada grupo de listas (A, B y C).</p></li>
<li><p><strong>Acumule</strong> el tiempo en segundos y el número de comparaciones para cada operación. Es posible que necesite repetir varias veces el procedimiento para medir tiempos de manera fiable.</p></li>
<li><p><strong>Cree</strong> gráficos boxplot para cada conjunto de listas con los siguientes aspectos, incluya en cada gráfica todos los algoritmos para que sean fáciles de comparar:</p>
<ul>
<li>Tiempo en segundos de los tres experimentos, por algoritmo.</li>
<li>Número de comparaciones de los tres experimentos, por algoritmo.</li>
<li>Longitudes de las intersecciones resultantes para A, B, C. Este también es un gráfico de control, úselo para detectar posibles errores.</li>
</ul></li>
</ul></li>
<li><p><strong>Análisis</strong>:</p>
<ul>
<li><strong>Analice</strong> los resultados obtenidos en los gráficos boxplot. Examine las diferencias en tiempo, número de comparaciones y longitud de las intersecciones entre los distintos algoritmos y conjuntos de listas.</li>
<li><strong>Discuta</strong> cualquier tendencia, anomalía o patrón interesante observado. Reflexione sobre cómo los diferentes algoritmos afectan el rendimiento y la eficiencia en las operaciones de intersección.</li>
</ul></li>
</ol>
<hr>
#
<h1>
<b>Solución</b>
</h1>
<section id="definimos-las-librerías-que-usaremos" class="level2">
<h2 class="anchored" data-anchor-id="definimos-las-librerías-que-usaremos"><strong>Definimos las librerías que usaremos:</strong></h2>
<div id="536e0b29" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="ad1ae1d9-6748-4011-f7ab-cbb4630bf040">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Librerías estándar</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> json</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Tuple, Optional</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> google.colab <span class="im">import</span> drive</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Montamos Google Drive</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>drive.mount(<span class="st">'/content/drive'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Mounted at /content/drive</code></pre>
</div>
</div>
</section>
<section id="carga-de-archivos-para-iniciar-procesamiento" class="level2">
<h2 class="anchored" data-anchor-id="carga-de-archivos-para-iniciar-procesamiento"><strong>Carga de archivos para iniciar procesamiento</strong></h2>
<p>Este bloque de código carga tres conjuntos de datos en formato JSON que contienen listas ordenadas para experimentos de intersección de conjuntos. Primero define las rutas a los archivos correspondientes a los conjuntos A (pares), B (tripletas) y C (tetrapletas), luego utiliza una función para leer cada archivo y cargar su contenido en memoria. Si algún archivo no se encuentra, muestra una advertencia. Finalmente, imprime cuántas instancias hay en cada conjunto y asigna los datos a variables individuales (<code>dataset_a</code>, <code>dataset_b</code>, <code>dataset_c</code>) para su uso posterior en la evaluación de algoritmos.</p>
<div id="44d156b5" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="b27cd3e4-c179-4423-a245-da33b3d33b6a">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Definir ruta base del directorio de trabajo</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>data_dir <span class="op">=</span> os.getcwd()</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Definir rutas absolutas a los archivos de datos</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>dataset_paths <span class="op">=</span> {</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"A"</span>: os.path.join(data_dir, <span class="st">"/content/postinglists-for-intersection-A-k=2.json"</span>),</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"B"</span>: os.path.join(data_dir, <span class="st">"/content/postinglists-for-intersection-B-k=3.json"</span>),</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"C"</span>: os.path.join(data_dir, <span class="st">"/content/postinglists-for-intersection-C-k=4.json"</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Función para cargar archivos JSON</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> load_json_data(file_path: <span class="bu">str</span>):</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> <span class="bu">open</span>(file_path, <span class="st">'r'</span>) <span class="im">as</span> <span class="bu">file</span>:</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> json.load(<span class="bu">file</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">FileNotFoundError</span>:</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Archivo no encontrado -&gt; </span><span class="sc">{</span>file_path<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Cargar los conjuntos de datos</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>datasets <span class="op">=</span> {key: load_json_data(path) <span class="cf">for</span> key, path <span class="kw">in</span> dataset_paths.items()}</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>dataset_a <span class="op">=</span> datasets[<span class="st">"A"</span>]</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>dataset_b <span class="op">=</span> datasets[<span class="st">"B"</span>]</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>dataset_c <span class="op">=</span> datasets[<span class="st">"C"</span>]</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Reportar tamaños de los conjuntos</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Conjunto de datos A (pares): </span><span class="sc">{</span><span class="bu">len</span>(dataset_a) <span class="cf">if</span> dataset_a <span class="cf">else</span> <span class="dv">0</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Conjunto de datos B (tripletas): </span><span class="sc">{</span><span class="bu">len</span>(dataset_a) <span class="cf">if</span> dataset_a <span class="cf">else</span> <span class="dv">0</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Conjunto de datos C (tetrapletas): </span><span class="sc">{</span><span class="bu">len</span>(dataset_a) <span class="cf">if</span> dataset_a <span class="cf">else</span> <span class="dv">0</span><span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Conjunto de datos A (pares): 200
Conjunto de datos B (tripletas): 200
Conjunto de datos C (tetrapletas): 200</code></pre>
</div>
</div>
</section>
</section>
<section id="implementación-y-descripción-técnica-de-los-algoritmos" class="level1">
<h1><strong>Implementación y Descripción Técnica de los Algoritmos</strong></h1>
<p>Este código define una clase llamada <code>ComparisonCounter</code> que permite contar cuántas comparaciones se realizan durante la ejecución de algoritmos de intersección de conjuntos. La clase incluye métodos para comparar dos valores y reiniciar el contador. Además, se define una función <code>load_datasets</code> que carga desde un archivo JSON tres conjuntos de datos etiquetados como A, B y C, y los retorna por separado para su procesamiento posterior.</p>
<div id="26283f11" class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Clase para contar comparaciones durante las intersecciones</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ComparisonCounter:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compare(<span class="va">self</span>, a, b) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Compara dos valores y registra la comparación."""</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a <span class="op">&lt;</span> b:</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> a <span class="op">&gt;</span> b:</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> reset(<span class="va">self</span>):</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Reinicia el contador a cero."""</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Función para cargar datasets A, B y C desde un JSON</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> load_datasets(path: <span class="bu">str</span>):</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(path, <span class="st">'r'</span>, encoding<span class="op">=</span><span class="st">'utf-8'</span>) <span class="im">as</span> <span class="bu">file</span>:</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> json.load(<span class="bu">file</span>)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data.get(<span class="st">'A'</span>), data.get(<span class="st">'B'</span>), data.get(<span class="st">'C'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="algoritmos-de-búsqueda" class="level2">
<h2 class="anchored" data-anchor-id="algoritmos-de-búsqueda"><strong>Algoritmos de búsqueda</strong></h2>
<section id="función-de-búsqueda-binaria" class="level3">
<h3 class="anchored" data-anchor-id="función-de-búsqueda-binaria"><strong>Función de búsqueda binaria</strong></h3>
<p>Esta función implementa una <strong>búsqueda binaria instrumentada</strong>, que busca un elemento <code>x</code> dentro de una lista ordenada <code>arr</code>, mientras <strong>registra el número de comparaciones</strong> realizadas mediante un objeto <code>ComparisonCounter</code>. Devuelve el índice donde se encuentra <code>x</code>, o <code>-1</code> si no está presente.</p>
<div id="047eae12" class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> instrumented_binary_search(</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    arr: <span class="bu">list</span>[<span class="bu">int</span>],</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    x: <span class="bu">int</span>,</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    low: <span class="bu">int</span> <span class="op">=</span> <span class="dv">0</span>,</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    high: Optional[<span class="bu">int</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    counter: ComparisonCounter <span class="op">=</span> <span class="va">None</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Realiza una búsqueda binaria en `arr` para encontrar `x`,</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">    registrando las comparaciones realizadas mediante un contador.</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co">        arr (list[int]): Lista ordenada donde buscar.</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="co">        x (int): Elemento objetivo.</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="co">        low (int): Límite inferior del rango de búsqueda.</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co">        high (Optional[int]): Límite superior (inclusive).</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="co">        counter (ComparisonCounter): Contador de comparaciones obligatorio.</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="co">        int: Índice de `x` si se encuentra, o -1 en caso contrario.</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> counter <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Se requiere un ComparisonCounter."</span>)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    high <span class="op">=</span> <span class="bu">len</span>(arr) <span class="op">-</span> <span class="dv">1</span> <span class="cf">if</span> high <span class="kw">is</span> <span class="va">None</span> <span class="cf">else</span> high</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> low <span class="op">&lt;=</span> high:</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">=</span> (low <span class="op">+</span> high) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">cmp</span> <span class="op">=</span> counter.compare(arr[mid], x)</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">cmp</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mid</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="bu">cmp</span> <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>            low <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>            high <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="dobling-search-b1" class="level3">
<h3 class="anchored" data-anchor-id="dobling-search-b1"><strong>Dobling search (B1)</strong></h3>
<p>Esta función realiza una <strong>búsqueda exponencial seguida de una búsqueda binaria</strong> para localizar un elemento <code>x</code> en una lista ordenada <code>arr</code>, comenzando desde una posición inicial <code>start</code>. Usa un contador (<code>ComparisonCounter</code>) para registrar las comparaciones realizadas. Si encuentra el elemento, retorna su índice; si no, devuelve la posición donde se debería insertar (<code>upper bound</code>).</p>
<div id="mkw3MtcXoXgi" class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exponential_binary_search(</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    arr: <span class="bu">list</span>[<span class="bu">int</span>],</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    x: <span class="bu">int</span>,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    start: <span class="bu">int</span> <span class="op">=</span> <span class="dv">0</span>,</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    counter: ComparisonCounter <span class="op">=</span> <span class="va">None</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Realiza una búsqueda exponencial seguida de una búsqueda binaria para encontrar `x`.</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">        arr (List[int]): Lista ordenada donde buscar.</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co">        x (int): Elemento objetivo.</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">        start (int): Índice inicial desde donde buscar.</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co">        counter (ComparisonCounter): Objeto contador para registrar comparaciones.</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co">        int: Índice de `x` si se encuentra, o posición de inserción (upper bound) si no está presente.</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> counter <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Se requiere un ComparisonCounter."</span>)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    bound <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Expansión exponencial hasta encontrar un rango que pueda contener x</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> start <span class="op">+</span> bound <span class="op">&lt;</span> n <span class="kw">and</span> counter.compare(arr[start <span class="op">+</span> bound], x) <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>        bound <span class="op">*=</span> <span class="dv">2</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Definición del rango para la búsqueda binaria</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    low <span class="op">=</span> start <span class="op">+</span> bound <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    high <span class="op">=</span> <span class="bu">min</span>(start <span class="op">+</span> bound, n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Búsqueda binaria instrumentada dentro del rango encontrado</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> instrumented_binary_search(arr, x, low, high, counter)</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pos <span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="dv">0</span> <span class="cf">else</span> high <span class="op">+</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="búsqueda-b2-doble-doubling" class="level3">
<h3 class="anchored" data-anchor-id="búsqueda-b2-doble-doubling"><strong>Búsqueda B2 (doble doubling)</strong></h3>
<p>Esta función implementa la búsqueda B2, que consiste en un <strong>doble salto exponencial</strong> para encontrar un rango adecuado y luego una <strong>búsqueda exponencial interna</strong> (con binaria incluida) para localizar un elemento <code>x</code> en una lista ordenada <code>arr</code>. Utiliza un <code>ComparisonCounter</code> para contar comparaciones y devuelve el índice de <code>x</code> si se encuentra, o su posición de inserción si no.</p>
<div id="nFuN6tXdoXOS" class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> double_exponential_search(</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    arr: <span class="bu">list</span>[<span class="bu">int</span>],</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    x: <span class="bu">int</span>,</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    start: <span class="bu">int</span> <span class="op">=</span> <span class="dv">0</span>,</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    counter: ComparisonCounter <span class="op">=</span> <span class="va">None</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Búsqueda B2 (doble salto exponencial + búsqueda exponencial interna).</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co">        arr (list[int]): Lista ordenada donde buscar.</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">        x (int): Elemento objetivo.</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">        start (int): Índice inicial desde donde buscar.</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">        counter (ComparisonCounter): Contador de comparaciones (requerido).</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="co">        int: Índice de `x` si se encuentra, o posición de inserción si no está.</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> counter <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Se requiere un ComparisonCounter."</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    exp <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Salto exponencial externo para delimitar un rango amplio</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> start <span class="op">+</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> exp) <span class="op">&lt;</span> n <span class="kw">and</span> counter.compare(arr[start <span class="op">+</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> exp)], x) <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>        exp <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Definir los límites internos</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    outer_low <span class="op">=</span> start <span class="op">+</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> (exp <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    outer_high <span class="op">=</span> <span class="bu">min</span>(start <span class="op">+</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> exp), n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Realizar búsqueda exponencial interna dentro del rango identificado</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> exponential_binary_search(arr, x, outer_low, counter)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="algoritmos-de-intersección" class="level2">
<h2 class="anchored" data-anchor-id="algoritmos-de-intersección"><strong>Algoritmos de intersección</strong></h2>
<section id="melding-intersection-me" class="level3">
<h3 class="anchored" data-anchor-id="melding-intersection-me"><strong>Melding Intersection (ME)</strong></h3>
<p>Esta función implementa el algoritmo <strong>Melding (ME)</strong> para calcular la intersección de múltiples listas ordenadas. Utiliza punteros sincronizados para comparar los elementos actuales de cada lista y avanzar solo aquellos que aún no alcanzan el valor máximo observado. Si todos coinciden, el valor se agrega a la intersección. Usa un <code>ComparisonCounter</code> para registrar el número de comparaciones realizadas, y retorna tanto la lista resultante como ese conteo.</p>
<div id="OJvj1sR-qQsH" class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> melding_intersection(</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    sets: <span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">int</span>]],</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    counter: ComparisonCounter <span class="op">=</span> <span class="va">None</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Tuple[<span class="bu">list</span>[<span class="bu">int</span>], <span class="bu">int</span>]:</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Realiza la intersección de múltiples listas ordenadas usando el algoritmo Melding (ME).</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Este método compara los elementos actuales de cada lista y avanza los punteros</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">    hasta que todos coincidan en un mismo valor, o se alcanza el final de alguna lista.</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co">        sets (list[list[int]]): Listas ordenadas a intersectar.</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="co">        counter (ComparisonCounter, opcional): Objeto para contar comparaciones.</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co">        Tuple[list[int], int]:</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="co">            - Lista resultante con los elementos comunes.</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co">            - Número total de comparaciones realizadas.</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> counter <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        counter <span class="op">=</span> ComparisonCounter()</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> sets:</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [], counter.count</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(sets) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sets[<span class="dv">0</span>], counter.count</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    pointers <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="bu">len</span>(sets)</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">all</span>(ptr <span class="op">&lt;</span> <span class="bu">len</span>(sets[i]) <span class="cf">for</span> i, ptr <span class="kw">in</span> <span class="bu">enumerate</span>(pointers)):</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>        current_values <span class="op">=</span> [sets[i][ptr] <span class="cf">for</span> i, ptr <span class="kw">in</span> <span class="bu">enumerate</span>(pointers)]</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>        max_val <span class="op">=</span> <span class="bu">max</span>(current_values, key<span class="op">=</span><span class="kw">lambda</span> v: v)</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Contar comparaciones al encontrar el máximo</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> val <span class="kw">in</span> current_values:</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>            counter.compare(val, max_val)</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">all</span>(counter.compare(val, max_val) <span class="op">==</span> <span class="dv">0</span> <span class="cf">for</span> val <span class="kw">in</span> current_values):</span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>            result.append(max_val)</span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>            pointers <span class="op">=</span> [ptr <span class="op">+</span> <span class="dv">1</span> <span class="cf">for</span> ptr <span class="kw">in</span> pointers]</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(sets)):</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> pointers[i] <span class="op">&lt;</span> <span class="bu">len</span>(sets[i]) <span class="kw">and</span> counter.compare(sets[i][pointers[i]], max_val) <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>                    pointers[i] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result, counter.count</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="baeza-yates" class="level3">
<h3 class="anchored" data-anchor-id="baeza-yates"><strong>Baeza-Yates</strong></h3>
<p>Esta función implementa el algoritmo Baeza-Yates utilizando búsqueda binaria instrumentada para calcular la intersección de varias listas ordenadas. Ordena las listas de menor a mayor para reducir el número de comparaciones, luego busca cada elemento del conjunto más pequeño en los demás. Usa un ComparisonCounter para registrar las comparaciones realizadas y devuelve tanto la intersección resultante como el conteo total de comparaciones.</p>
<div id="PTcOjWa5qW4A" class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> baeza_yates_bisection(</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    sets: <span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">int</span>]],</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    counter: ComparisonCounter <span class="op">=</span> <span class="va">None</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Tuple[<span class="bu">list</span>[<span class="bu">int</span>], <span class="bu">int</span>]:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Aplica el algoritmo Baeza-Yates usando búsqueda binaria instrumentada para obtener la intersección</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co">    de múltiples listas ordenadas.</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Se ordenan las listas por tamaño ascendente para minimizar comparaciones en búsquedas sucesivas.</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co">        sets (list[list[int]]): Listas ordenadas a intersectar.</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="co">        counter (ComparisonCounter, opcional): Objeto para contar comparaciones.</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="co">        Tuple[list[int], int]:</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="co">            - lista resultante con los elementos comunes.</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="co">            - Número total de comparaciones realizadas.</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> counter <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        counter <span class="op">=</span> ComparisonCounter()</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> sets:</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [], counter.count</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(sets) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sets[<span class="dv">0</span>], counter.count</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ordenar listas por tamaño ascendente para eficiencia</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    sorted_sets <span class="op">=</span> <span class="bu">sorted</span>(sets, key<span class="op">=</span><span class="bu">len</span>)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> sorted_sets[<span class="dv">0</span>].copy()</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> sorted_sets[<span class="dv">1</span>:]:</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> [e <span class="cf">for</span> e <span class="kw">in</span> result <span class="cf">if</span> instrumented_binary_search(s, e, <span class="dv">0</span>, <span class="va">None</span>, counter) <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> result:</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result, counter.count</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="baeza-yates-con-búsqueda-exponencial" class="level3">
<h3 class="anchored" data-anchor-id="baeza-yates-con-búsqueda-exponencial"><strong>Baeza-Yates con búsqueda exponencial</strong></h3>
<p>Esta función implementa la variante <strong>B1 del algoritmo Baeza-Yates</strong>, que utiliza <strong>búsqueda exponencial</strong> para encontrar un elemento en múltiples listas ordenadas. Para cada elemento del conjunto más pequeño, verifica si está presente en los demás conjuntos usando <code>exponential_binary_search</code>. Registra las comparaciones mediante un <code>ComparisonCounter</code> y retorna la intersección obtenida junto con el número total de comparaciones realizadas.</p>
<div id="OzFRr7bQqdqs" class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> baeza_yates_b1(</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    sets: <span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">int</span>]],</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    counter: ComparisonCounter <span class="op">=</span> <span class="va">None</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Tuple[<span class="bu">list</span>[<span class="bu">int</span>], <span class="bu">int</span>]:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Aplica el algoritmo Baeza-Yates con búsqueda exponencial (B1) para intersectar múltiples listas ordenadas.</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Para cada elemento del conjunto más pequeño, se verifica su presencia en los demás conjuntos</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">    utilizando búsqueda exponencial seguida de búsqueda binaria.</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="co">        sets (list[list[int]]): Listas ordenadas a intersectar.</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="co">        counter (ComparisonCounter, opcional): Objeto para contar comparaciones.</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="co">        Tuple[list[int], int]:</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="co">            - Lista con los elementos comunes.</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="co">            - Total de comparaciones realizadas.</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> counter <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        counter <span class="op">=</span> ComparisonCounter()</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> sets:</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [], counter.count</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(sets) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sets[<span class="dv">0</span>], counter.count</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    sorted_sets <span class="op">=</span> <span class="bu">sorted</span>(sets, key<span class="op">=</span><span class="bu">len</span>)</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    smallest <span class="op">=</span> sorted_sets[<span class="dv">0</span>]</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> e <span class="kw">in</span> smallest:</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">all</span>(exponential_binary_search(s, e, <span class="dv">0</span>, counter) <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span> <span class="cf">for</span> s <span class="kw">in</span> sorted_sets[<span class="dv">1</span>:]):</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>            result.append(e)</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result, counter.count</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="baeza-yates-con-búsqueda-exponencial-b2" class="level3">
<h3 class="anchored" data-anchor-id="baeza-yates-con-búsqueda-exponencial-b2"><strong>Baeza-Yates con búsqueda exponencial (B2)</strong></h3>
<p>Esta función implementa la variante <strong>B2 del algoritmo Baeza-Yates</strong>, que utiliza una <strong>búsqueda doblemente exponencial</strong> para calcular la intersección de listas ordenadas. Optimiza el proceso guardando la última posición de búsqueda en cada lista, evitando comenzar desde el inicio cada vez. Usa un <code>ComparisonCounter</code> para registrar comparaciones y retorna la lista de elementos comunes junto con el total de comparaciones realizadas.</p>
<div id="9xOVLkJeqlAd" class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> baeza_yates_b2(</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    sets: <span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">int</span>]],</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    counter: ComparisonCounter <span class="op">=</span> <span class="va">None</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Tuple[<span class="bu">list</span>[<span class="bu">int</span>], <span class="bu">int</span>]:</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Algoritmo Baeza-Yates con búsqueda doblemente exponencial</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">    (B2) para intersección de listas ordenadas.</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Optimiza las búsquedas recordando la última posición encontrada</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co">    en cada lista, evitando escanear desde el principio cada vez.</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="co">        sets (list[list[int]]): Listas ordenadas a intersectar.</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="co">        counter (ComparisonCounter, opcional): Objeto para contar comparaciones.</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co">        Tuple[list[int], int]:</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="co">            - Lista resultante con los elementos comunes.</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a><span class="co">            - Número total de comparaciones realizadas.</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> counter <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        counter <span class="op">=</span> ComparisonCounter()</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> sets:</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [], counter.count</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(sets) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sets[<span class="dv">0</span>], counter.count</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>    sorted_sets <span class="op">=</span> <span class="bu">sorted</span>(sets, key<span class="op">=</span><span class="bu">len</span>)</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>    smallest <span class="op">=</span> sorted_sets[<span class="dv">0</span>]</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>    positions <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="bu">len</span>(sorted_sets)</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> e <span class="kw">in</span> smallest:</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>        matched <span class="op">=</span> <span class="va">True</span></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(sorted_sets)):</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>            s <span class="op">=</span> sorted_sets[i]</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>            start_pos <span class="op">=</span> positions[i]</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">=</span> double_exponential_search(s, e, start_pos, counter)</span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(s) <span class="kw">or</span> counter.compare(s[pos], e) <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>                matched <span class="op">=</span> <span class="va">False</span></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>            <span class="co"># actualizar la posición para la siguiente búsqueda</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>            positions[i] <span class="op">=</span> pos</span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> matched:</span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>            result.append(e)</span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result, counter.count</span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="barbay-kenyon-bk" class="level3">
<h3 class="anchored" data-anchor-id="barbay-kenyon-bk"><strong>Barbay &amp; Kenyon (BK)</strong></h3>
<p>Esta función implementa el algoritmo <strong>Barbay &amp; Kenyon (BK)</strong> para calcular la intersección de múltiples listas ordenadas. Utiliza una estrategia <strong>adaptativa</strong>, donde cada lista busca un candidato común utilizando una función de búsqueda eficiente (por defecto, búsqueda exponencial). Los punteros se actualizan dinámicamente para evitar retrocesos, y se registra el número total de comparaciones con un <code>ComparisonCounter</code>. La función devuelve la intersección resultante y el número total de comparaciones realizadas.</p>
<div id="dcae9849" class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bk_intersection(</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    lists: <span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">int</span>]],</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    findpos: <span class="bu">callable</span> <span class="op">=</span> exponential_binary_search</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Tuple[<span class="bu">list</span>[<span class="bu">int</span>], <span class="bu">int</span>]:</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Algoritmo de intersección Barbay &amp; Kenyon (BK) para múltiples listas ordenadas.</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Usa una estrategia adaptativa basada en búsqueda exponencial (por defecto) para encontrar coincidencias,</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co">    avanzando los punteros dinámicamente según el valor candidato.</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co">        lists (list[list[int]]): Conjuntos ordenados a intersectar.</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co">        findpos (callable): Función de búsqueda con conteo de comparaciones (por defecto, búsqueda exponencial + binaria).</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co">        Tuple[list[int], int]:</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="co">            - lista con los elementos comunes a todas las listas.</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="co">            - Número total de comparaciones realizadas.</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    counter <span class="op">=</span> ComparisonCounter()</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(lists)</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> <span class="bu">any</span>(<span class="kw">not</span> lst <span class="cf">for</span> lst <span class="kw">in</span> lists):</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [], <span class="dv">0</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    pointers <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Valor inicial candidato</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    candidate <span class="op">=</span> lists[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>        match_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">=</span> findpos(lists[i], candidate, pointers[i], counter)</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>            pointers[i] <span class="op">=</span> pos</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(lists[i]):</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> result, counter.count</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>            value <span class="op">=</span> lists[i][pos]</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> value <span class="op">==</span> candidate:</span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>                match_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> match_count <span class="op">==</span> n:</span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>                    result.append(candidate)</span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>                    match_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>                pointers[i] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> pointers[i] <span class="op">&gt;=</span> <span class="bu">len</span>(lists[i]):</span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> result, counter.count</span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a>                candidate <span class="op">=</span> lists[i][pointers[i]]</span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a>                match_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a>                candidate <span class="op">=</span> value</span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result, counter.count  <span class="co"># redundante pero explícito</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
</section>
</section>
</section>
<section id="desarrollo-del-experimento" class="level1">
<h1><strong>Desarrollo del Experimento</strong></h1>
<p>Para evaluar el comportamiento de cada algoritmo, se desarrollaron funciones que permiten ejecutar y registrar su rendimiento sobre distintos tipos de conjuntos. Específicamente, se midieron tres métricas fundamentales para cada algoritmo y conjunto:</p>
<ul>
<li><strong>Tiempo de ejecución</strong> (en segundos).</li>
<li><strong>Número de comparaciones realizadas</strong> (en el modelo de comparación).</li>
<li><strong>Tamaño de la intersección resultante</strong> (como control de consistencia).</li>
</ul>
<p>Estos datos permiten analizar de forma cuantitativa la eficiencia algorítmica bajo diferentes configuraciones de entrada.</p>
<div id="0515ba51" class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Diccionerio de algoritmos</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>algoritmos <span class="op">=</span> {</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ME'</span>: melding_intersection,</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'BY_bis'</span>: baeza_yates_bisection,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'BY_B1'</span>: baeza_yates_b1,</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'BY_B2'</span>: baeza_yates_b2,</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'BK'</span>: bk_intersection,</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ejecutar_algoritmo(</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    algoritmo: <span class="bu">callable</span>,</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    grupos: <span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">int</span>]]</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">list</span>[Tuple[<span class="bu">float</span>, <span class="bu">int</span>, <span class="bu">int</span>]]:</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Ejecuta un algoritmo sobre una lista de grupos (pares, tripletas, etc.)</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="co">        algoritmo (callable): Función de intersección a aplicar.</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="co">        grupos (list[list[int]]): Lista de listas ordenadas a procesar.</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a><span class="co">        list[Tuple[float, int, int]]: Lista de resultados por grupo en forma de</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a><span class="co">        (tiempo de ejecución, comparaciones, longitud de intersección).</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>    resultados <span class="op">=</span> []</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> grupo <span class="kw">in</span> grupos:</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>        inicio <span class="op">=</span> time.time()</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>        interseccion, comparaciones <span class="op">=</span> algoritmo(grupo)</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>        fin <span class="op">=</span> time.time()</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>        resultados.append((fin <span class="op">-</span> inicio, comparaciones, <span class="bu">len</span>(interseccion)))</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> resultados</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_algorithms_on_datasets(</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>    dataset_a: <span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">int</span>]]],</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>    dataset_b: <span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">int</span>]]],</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>    dataset_c: <span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">int</span>]]]</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">dict</span>:</span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a><span class="co">    Evalúa todos los algoritmos definidos sobre los datasets A, B y C.</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a><span class="co">        dataset_a/b/c: Listas de grupos ordenados (pares, tripletas, tetrapletas).</span></span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a><span class="co">        dict: Resultados estructurados por algoritmo y dataset.</span></span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a>    etiquetas <span class="op">=</span> {<span class="st">'A'</span>: dataset_a, <span class="st">'B'</span>: dataset_b, <span class="st">'C'</span>: dataset_c}</span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a>    resultados <span class="op">=</span> {}</span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nombre, algoritmo <span class="kw">in</span> algoritmos.items():</span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a>        resultados[nombre] <span class="op">=</span> {}</span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> etiqueta, dataset <span class="kw">in</span> etiquetas.items():</span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a>            resultados[nombre][etiqueta] <span class="op">=</span> ejecutar_algoritmo(algoritmo, dataset)</span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> resultados</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="conversión-de-resultados-a-formato-tabular" class="level2">
<h2 class="anchored" data-anchor-id="conversión-de-resultados-a-formato-tabular"><strong>Conversión de Resultados a Formato Tabular</strong></h2>
<p>Una vez obtenidas las métricas de evaluación, se procede a transformar los resultados en una estructura tabular para facilitar su análisis. Para ello, se construye un DataFrame plano en el que cada fila representa una combinación de algoritmo y conjunto de datos, junto con sus respectivas métricas:</p>
<ul>
<li><strong>Algoritmo aplicado</strong></li>
<li><strong>Tipo de conjunto</strong> (A, B o C)</li>
<li><strong>Tiempo de ejecución</strong></li>
<li><strong>Número de comparaciones realizadas</strong></li>
<li><strong>Longitud de la intersección obtenida</strong></li>
</ul>
<p>Esta representación permite comparar el comportamiento de los algoritmos de forma clara y sistemática a lo largo de distintas configuraciones experimentales.</p>
<div id="43cd8e19" class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> resultados_a_dataframe(resultados: <span class="bu">dict</span>) <span class="op">-&gt;</span> pd.DataFrame:</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Convierte el diccionario de resultados en un DataFrame plano.</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co">        resultados (dict): Diccionario con resultados de los algoritmos.</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="co">        pd.DataFrame: Tabla con columnas: algoritmo, conjunto, tiempo, comparaciones, long_inter.</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    registros <span class="op">=</span> [</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        {</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>            <span class="st">"algoritmo"</span>: algoritmo,</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>            <span class="st">"conjunto"</span>: conjunto,</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>            <span class="st">"tiempo"</span>: tiempo,</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>            <span class="st">"comparaciones"</span>: comparaciones,</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>            <span class="st">"long_inter"</span>: longitud</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> algoritmo, por_conjunto <span class="kw">in</span> resultados.items()</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> conjunto, ejecuciones <span class="kw">in</span> por_conjunto.items()</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> tiempo, comparaciones, longitud <span class="kw">in</span> ejecuciones</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.DataFrame(registros)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="gdMvb36-wTSm" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:423}}" data-outputid="81f32523-6a86-4d36-f166-5454766fab86" data-execution_count="64">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>resultados <span class="op">=</span> evaluate_algorithms_on_datasets(dataset_a, dataset_b, dataset_c)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> resultados_a_dataframe(resultados)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>display(df)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>df.to_csv(<span class="st">"resultados_1.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="df-c5c8cb69-4b7e-44c8-a2b5-0ca012425b3f" class="colab-df-container">
    <div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">algoritmo</th>
<th data-quarto-table-cell-role="th">conjunto</th>
<th data-quarto-table-cell-role="th">tiempo</th>
<th data-quarto-table-cell-role="th">comparaciones</th>
<th data-quarto-table-cell-role="th">long_inter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>ME</td>
<td>A</td>
<td>0.008232</td>
<td>22642</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>ME</td>
<td>A</td>
<td>0.004466</td>
<td>4257</td>
<td>6</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>ME</td>
<td>A</td>
<td>0.001115</td>
<td>3305</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>ME</td>
<td>A</td>
<td>0.001682</td>
<td>5543</td>
<td>16</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>ME</td>
<td>A</td>
<td>0.001428</td>
<td>4446</td>
<td>5</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2995</td>
<td>BK</td>
<td>C</td>
<td>0.000309</td>
<td>521</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2996</td>
<td>BK</td>
<td>C</td>
<td>0.001811</td>
<td>780</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2997</td>
<td>BK</td>
<td>C</td>
<td>0.000568</td>
<td>912</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2998</td>
<td>BK</td>
<td>C</td>
<td>0.000138</td>
<td>175</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2999</td>
<td>BK</td>
<td>C</td>
<td>0.000173</td>
<td>284</td>
<td>0</td>
</tr>
</tbody>
</table>

<p>3000 rows × 5 columns</p>
</div>
    <div class="colab-df-buttons">

  <div class="colab-df-container">
    <button class="colab-df-convert" onclick="convertToInteractive('df-c5c8cb69-4b7e-44c8-a2b5-0ca012425b3f')" title="Convert this dataframe to an interactive table." style="display:none;">

  <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewbox="0 -960 960 960">
    <path d="M120-120v-720h720v720H120Zm60-500h600v-160H180v160Zm220 220h160v-160H400v160Zm0 220h160v-160H400v160ZM180-400h160v-160H180v160Zm440 0h160v-160H620v160ZM180-180h160v-160H180v160Zm440 0h160v-160H620v160Z"></path>
  </svg>
    </button>

  <style>
    .colab-df-container {
      display:flex;
      gap: 12px;
    }

    .colab-df-convert {
      background-color: #E8F0FE;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: none;
      fill: #1967D2;
      height: 32px;
      padding: 0 0 0 0;
      width: 32px;
    }

    .colab-df-convert:hover {
      background-color: #E2EBFA;
      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);
      fill: #174EA6;
    }

    .colab-df-buttons div {
      margin-bottom: 4px;
    }

    [theme=dark] .colab-df-convert {
      background-color: #3B4455;
      fill: #D2E3FC;
    }

    [theme=dark] .colab-df-convert:hover {
      background-color: #434B5C;
      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));
      fill: #FFFFFF;
    }
  </style>

    <script>
      const buttonEl =
        document.querySelector('#df-c5c8cb69-4b7e-44c8-a2b5-0ca012425b3f button.colab-df-convert');
      buttonEl.style.display =
        google.colab.kernel.accessAllowed ? 'block' : 'none';

      async function convertToInteractive(key) {
        const element = document.querySelector('#df-c5c8cb69-4b7e-44c8-a2b5-0ca012425b3f');
        const dataTable =
          await google.colab.kernel.invokeFunction('convertToInteractive',
                                                    [key], {});
        if (!dataTable) return;

        const docLinkHtml = 'Like what you see? Visit the ' +
          '<a target="_blank" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'
          + ' to learn more about interactive tables.';
        element.innerHTML = '';
        dataTable['output_type'] = 'display_data';
        await google.colab.output.renderOutput(dataTable, element);
        const docLink = document.createElement('div');
        docLink.innerHTML = docLinkHtml;
        element.appendChild(docLink);
      }
    </script>
  </div>


    <div id="df-d84e80a7-c38d-46bf-9f05-aa7c2847cd79">
      <button class="colab-df-quickchart" onclick="quickchart('df-d84e80a7-c38d-46bf-9f05-aa7c2847cd79')" title="Suggest charts" style="display:none;">

<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewbox="0 0 24 24" width="24px">
    <g>
        <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"></path>
    </g>
</svg>
      </button>

<style>
  .colab-df-quickchart {
      --bg-color: #E8F0FE;
      --fill-color: #1967D2;
      --hover-bg-color: #E2EBFA;
      --hover-fill-color: #174EA6;
      --disabled-fill-color: #AAA;
      --disabled-bg-color: #DDD;
  }

  [theme=dark] .colab-df-quickchart {
      --bg-color: #3B4455;
      --fill-color: #D2E3FC;
      --hover-bg-color: #434B5C;
      --hover-fill-color: #FFFFFF;
      --disabled-bg-color: #3B4455;
      --disabled-fill-color: #666;
  }

  .colab-df-quickchart {
    background-color: var(--bg-color);
    border: none;
    border-radius: 50%;
    cursor: pointer;
    display: none;
    fill: var(--fill-color);
    height: 32px;
    padding: 0;
    width: 32px;
  }

  .colab-df-quickchart:hover {
    background-color: var(--hover-bg-color);
    box-shadow: 0 1px 2px rgba(60, 64, 67, 0.3), 0 1px 3px 1px rgba(60, 64, 67, 0.15);
    fill: var(--button-hover-fill-color);
  }

  .colab-df-quickchart-complete:disabled,
  .colab-df-quickchart-complete:disabled:hover {
    background-color: var(--disabled-bg-color);
    fill: var(--disabled-fill-color);
    box-shadow: none;
  }

  .colab-df-spinner {
    border: 2px solid var(--fill-color);
    border-color: transparent;
    border-bottom-color: var(--fill-color);
    animation:
      spin 1s steps(1) infinite;
  }

  @keyframes spin {
    0% {
      border-color: transparent;
      border-bottom-color: var(--fill-color);
      border-left-color: var(--fill-color);
    }
    20% {
      border-color: transparent;
      border-left-color: var(--fill-color);
      border-top-color: var(--fill-color);
    }
    30% {
      border-color: transparent;
      border-left-color: var(--fill-color);
      border-top-color: var(--fill-color);
      border-right-color: var(--fill-color);
    }
    40% {
      border-color: transparent;
      border-right-color: var(--fill-color);
      border-top-color: var(--fill-color);
    }
    60% {
      border-color: transparent;
      border-right-color: var(--fill-color);
    }
    80% {
      border-color: transparent;
      border-right-color: var(--fill-color);
      border-bottom-color: var(--fill-color);
    }
    90% {
      border-color: transparent;
      border-bottom-color: var(--fill-color);
    }
  }
</style>

      <script>
        async function quickchart(key) {
          const quickchartButtonEl =
            document.querySelector('#' + key + ' button');
          quickchartButtonEl.disabled = true;  // To prevent multiple clicks.
          quickchartButtonEl.classList.add('colab-df-spinner');
          try {
            const charts = await google.colab.kernel.invokeFunction(
                'suggestCharts', [key], {});
          } catch (error) {
            console.error('Error during call to suggestCharts:', error);
          }
          quickchartButtonEl.classList.remove('colab-df-spinner');
          quickchartButtonEl.classList.add('colab-df-quickchart-complete');
        }
        (() => {
          let quickchartButtonEl =
            document.querySelector('#df-d84e80a7-c38d-46bf-9f05-aa7c2847cd79 button');
          quickchartButtonEl.style.display =
            google.colab.kernel.accessAllowed ? 'block' : 'none';
        })();
      </script>
    </div>

  <div id="id_7a3759cd-049a-4601-a652-9e225a626bb6">
    <style>
      .colab-df-generate {
        background-color: #E8F0FE;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        display: none;
        fill: #1967D2;
        height: 32px;
        padding: 0 0 0 0;
        width: 32px;
      }

      .colab-df-generate:hover {
        background-color: #E2EBFA;
        box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);
        fill: #174EA6;
      }

      [theme=dark] .colab-df-generate {
        background-color: #3B4455;
        fill: #D2E3FC;
      }

      [theme=dark] .colab-df-generate:hover {
        background-color: #434B5C;
        box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
        filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));
        fill: #FFFFFF;
      }
    </style>
    <button class="colab-df-generate" onclick="generateWithVariable('df_1')" title="Generate code using this dataframe." style="display:none;">

  <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewbox="0 0 24 24" width="24px">
    <path d="M7,19H8.4L18.45,9,17,7.55,7,17.6ZM5,21V16.75L18.45,3.32a2,2,0,0,1,2.83,0l1.4,1.43a1.91,1.91,0,0,1,.58,1.4,1.91,1.91,0,0,1-.58,1.4L9.25,21ZM18.45,9,17,7.55Zm-12,3A5.31,5.31,0,0,0,4.9,8.1,5.31,5.31,0,0,0,1,6.5,5.31,5.31,0,0,0,4.9,4.9,5.31,5.31,0,0,0,6.5,1,5.31,5.31,0,0,0,8.1,4.9,5.31,5.31,0,0,0,12,6.5,5.46,5.46,0,0,0,6.5,12Z"></path>
  </svg>
    </button>
    <script>
      (() => {
      const buttonEl =
        document.querySelector('#id_7a3759cd-049a-4601-a652-9e225a626bb6 button.colab-df-generate');
      buttonEl.style.display =
        google.colab.kernel.accessAllowed ? 'block' : 'none';

      buttonEl.onclick = () => {
        google.colab.notebook.generateWithVariable('df_1');
      }
      })();
    </script>
  </div>

    </div>
  </div>
</div>
</div>
<hr>
<p>Con el objetivo de comparar de manera clara y estructurada el comportamiento de los distintos algoritmos de intersección, se generarán visualizaciones que resumen su rendimiento sobre los conjuntos de datos evaluados. En particular, se utilizarán diagramas de caja para analizar las siguientes métricas clave:</p>
<ul>
<li><strong>Tiempo de ejecución</strong></li>
<li><strong>Número de comparaciones realizadas</strong></li>
<li><strong>Tamaño de la intersección obtenida</strong></li>
</ul>
<p>Estas representaciones permitirán identificar patrones, anomalías y diferencias de eficiencia entre algoritmos bajo diversas configuraciones de entrada.</p>
</section>
<section id="boxplot-de-tiempos-de-ejecución-por-algoritmo-y-conjunto" class="level2">
<h2 class="anchored" data-anchor-id="boxplot-de-tiempos-de-ejecución-por-algoritmo-y-conjunto"><strong>Boxplot de Tiempos de Ejecución por Algoritmo y Conjunto</strong></h2>
<p>Este gráfico compara el rendimiento temporal de los algoritmos aplicados sobre los conjuntos A, B y C. El tiempo de ejecución, medido en segundos, permite evaluar la eficiencia computacional de cada método bajo distintas configuraciones de entrada. Esta métrica es fundamental para identificar algoritmos escalables y con buen desempeño práctico.</p>
<div id="D-KW79P5zYdu" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:607}}" data-outputid="80ae4270-d95f-4201-f80a-1af98e1a079b" data-execution_count="66">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_metric_boxplot(</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    df: pd.DataFrame,</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    metric: <span class="bu">str</span>,</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    title: <span class="bu">str</span>,</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    ylabel: <span class="bu">str</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Genera un boxplot para una métrica dada ('tiempo', 'comparaciones', etc.).</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="co">        df (pd.DataFrame): DataFrame con columnas 'algoritmo', 'conjunto' y la métrica.</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="co">        metric (str): Nombre de la columna a graficar.</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="co">        title (str): Título del gráfico.</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="co">        ylabel (str): Etiqueta del eje Y.</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    sns.boxplot(</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>        data<span class="op">=</span>df,</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>        x<span class="op">=</span><span class="st">"conjunto"</span>,</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>        y<span class="op">=</span>metric,</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>        hue<span class="op">=</span><span class="st">"algoritmo"</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"Conjunto"</span>)</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(ylabel)</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    plt.legend(title<span class="op">=</span><span class="st">"Algoritmo"</span>)</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Ejemplo de uso: gráfico de tiempos</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>plot_metric_boxplot(</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>    df,</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>    metric<span class="op">=</span><span class="st">"tiempo"</span>,</span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"Comparativa de tiempos por algoritmo y conjunto"</span>,</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>    ylabel<span class="op">=</span><span class="st">"Tiempo (s)"</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SegundoDavid_U5_T1_files/figure-html/cell-16-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="análisis-de-tiempos-de-ejecución" class="level3">
<h3 class="anchored" data-anchor-id="análisis-de-tiempos-de-ejecución"><strong>Análisis de Tiempos de Ejecución</strong></h3>
<p>A continuación se presentan las observaciones derivadas del análisis estadístico y visualización de tiempos de ejecución para los algoritmos evaluados en los tres conjuntos de datos.</p>
<hr>
</section>
<section id="conjunto-a" class="level3">
<h3 class="anchored" data-anchor-id="conjunto-a">Conjunto A</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 13%">
<col style="width: 26%">
<col style="width: 15%">
<col style="width: 28%">
</colgroup>
<thead>
<tr class="header">
<th>Algoritmo</th>
<th>Media (s)</th>
<th>Desviación estándar</th>
<th>Mediana (s)</th>
<th>Mín – Máx (s)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>BK</strong></td>
<td>0.00035</td>
<td>0.00030</td>
<td>0.00028</td>
<td>0.00005 – 0.00337</td>
</tr>
<tr class="even">
<td><strong>BY_bis</strong></td>
<td>0.00067</td>
<td>0.00015</td>
<td>0.00064</td>
<td>0.00050 – 0.00217</td>
</tr>
<tr class="odd">
<td><strong>BY_B1</strong></td>
<td>0.00118</td>
<td>0.00034</td>
<td>0.00112</td>
<td>0.00087 – 0.00481</td>
</tr>
<tr class="even">
<td><strong>BY_B2</strong></td>
<td>0.00126</td>
<td>0.00044</td>
<td>0.00118</td>
<td>0.00061 – 0.00446</td>
</tr>
<tr class="odd">
<td><strong>ME</strong></td>
<td>0.00267</td>
<td>0.00259</td>
<td>0.00153</td>
<td>0.00102 – 0.01116</td>
</tr>
</tbody>
</table>
<p><strong>Observación:</strong> El algoritmo <strong>BK</strong> es el más rápido y consistente, mientras que <strong>ME</strong> muestra el peor rendimiento. Las variantes de Baeza-Yates tienen buen desempeño, destacando <strong>BY_bis</strong> como el mejor entre ellas.</p>
<hr>
</section>
<section id="conjunto-b" class="level3">
<h3 class="anchored" data-anchor-id="conjunto-b">Conjunto B</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 13%">
<col style="width: 26%">
<col style="width: 15%">
<col style="width: 28%">
</colgroup>
<thead>
<tr class="header">
<th>Algoritmo</th>
<th>Media (s)</th>
<th>Desviación estándar</th>
<th>Mediana (s)</th>
<th>Mín – Máx (s)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>BK</strong></td>
<td>0.00066</td>
<td>0.00040</td>
<td>0.00055</td>
<td>0.00019 – 0.00461</td>
</tr>
<tr class="even">
<td><strong>BY_bis</strong></td>
<td>0.00091</td>
<td>0.00019</td>
<td>0.00088</td>
<td>0.00060 – 0.00163</td>
</tr>
<tr class="odd">
<td><strong>BY_B2</strong></td>
<td>0.00134</td>
<td>0.00033</td>
<td>0.00125</td>
<td>0.00088 – 0.00288</td>
</tr>
<tr class="even">
<td><strong>BY_B1</strong></td>
<td>0.00146</td>
<td>0.00037</td>
<td>0.00137</td>
<td>0.00100 – 0.00294</td>
</tr>
<tr class="odd">
<td><strong>ME</strong></td>
<td>0.00446</td>
<td>0.00416</td>
<td>0.00287</td>
<td>0.00126 – 0.01725</td>
</tr>
</tbody>
</table>
<p><strong>Observación:</strong> Nuevamente, <strong>BK</strong> lidera en eficiencia, con <strong>BY_bis</strong> como opción viable. <strong>ME</strong> se vuelve más ineficiente conforme aumentan el tamaño y cantidad de listas, reflejado en su alta media y dispersión.</p>
<hr>
</section>
<section id="conjunto-c" class="level3">
<h3 class="anchored" data-anchor-id="conjunto-c">Conjunto C</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 13%">
<col style="width: 26%">
<col style="width: 15%">
<col style="width: 28%">
</colgroup>
<thead>
<tr class="header">
<th>Algoritmo</th>
<th>Media (s)</th>
<th>Desviación estándar</th>
<th>Mediana (s)</th>
<th>Mín – Máx (s)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>BK</strong></td>
<td>0.00049</td>
<td>0.00024</td>
<td>0.00043</td>
<td>0.00019 – 0.00202</td>
</tr>
<tr class="even">
<td><strong>BY_B2</strong></td>
<td>0.00086</td>
<td>0.00027</td>
<td>0.00080</td>
<td>0.00046 – 0.00176</td>
</tr>
<tr class="odd">
<td><strong>BY_bis</strong></td>
<td>0.00087</td>
<td>0.00018</td>
<td>0.00084</td>
<td>0.00060 – 0.00144</td>
</tr>
<tr class="even">
<td><strong>BY_B1</strong></td>
<td>0.00110</td>
<td>0.00035</td>
<td>0.00104</td>
<td>0.00074 – 0.00269</td>
</tr>
<tr class="odd">
<td><strong>ME</strong></td>
<td>0.00291</td>
<td>0.00194</td>
<td>0.00251</td>
<td>0.00132 – 0.01159</td>
</tr>
</tbody>
</table>
<p><strong>Observación:</strong> A pesar del aumento en la complejidad de las tuplas, <strong>BK</strong> se mantiene como el más rápido. <strong>BY_B2</strong> mejora su rendimiento relativo gracias a su adaptabilidad. <strong>ME</strong> conserva su patrón de bajo rendimiento.</p>
<hr>
</section>
<section id="observaciones-generales" class="level3">
<h3 class="anchored" data-anchor-id="observaciones-generales">Observaciones Generales</h3>
<ul>
<li><p><strong>BK (Barbay &amp; Kenyon)</strong> es el algoritmo más eficiente y estable en todos los conjuntos. Su comportamiento adaptativo lo hace ideal para conjuntos ordenados de cualquier tamaño o complejidad.</p></li>
<li><p><strong>BY_bis</strong> ofrece una excelente relación entre simplicidad y rendimiento, siendo una alternativa práctica especialmente en casos donde no se requiere adaptabilidad compleja.</p></li>
<li><p>Las variantes <strong>BY_B1</strong> y <strong>BY_B2</strong> muestran mejoras en conjuntos más grandes, aunque con mayor costo computacional.</p></li>
<li><p><strong>ME (Melding)</strong> es el menos eficiente en todos los escenarios. Aunque sencillo, su estrategia de escaneo secuencial no escala bien con el número de listas ni con su longitud.</p></li>
</ul>
<hr>
</section>
</section>
<section id="boxplot-del-número-de-comparaciones-por-algoritmo-y-conjunto" class="level2">
<h2 class="anchored" data-anchor-id="boxplot-del-número-de-comparaciones-por-algoritmo-y-conjunto"><strong>Boxplot del Número de Comparaciones por Algoritmo y Conjunto</strong></h2>
<p>Esta visualización permite comparar la eficiencia computacional de los algoritmos evaluados, midiendo el número de comparaciones realizadas durante el proceso de intersección en los conjuntos A, B y C. Una menor cantidad de comparaciones sugiere un algoritmo más eficiente en términos de operaciones internas, sin comprometer necesariamente la calidad del resultado.</p>
<div id="zktRIg940n-9" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:607}}" data-outputid="d500ca26-ce80-458c-bd32-45ca1ee4b0ec" data-execution_count="69">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Gráfico boxplot del número de comparaciones por conjunto y algoritmo</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>sns.boxplot(</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    data<span class="op">=</span>df,</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span><span class="st">"conjunto"</span>,         <span class="co"># Conjuntos A, B, C</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="st">"comparaciones"</span>,    <span class="co"># Métrica: número de comparaciones</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    hue<span class="op">=</span><span class="st">"algoritmo"</span>       <span class="co"># Color por algoritmo</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Comparativa del Número de Comparaciones por Algoritmo y Conjunto"</span>)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Conjunto de prueba"</span>)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Número de Comparaciones"</span>)</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>plt.legend(title<span class="op">=</span><span class="st">"Algoritmo"</span>)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SegundoDavid_U5_T1_files/figure-html/cell-17-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="análisis-de-comparaciones" class="level3">
<h3 class="anchored" data-anchor-id="análisis-de-comparaciones"><strong>Análisis de Comparaciones</strong></h3>
<p>Este análisis examina el número de comparaciones realizadas por cada algoritmo durante las operaciones de intersección de conjuntos ordenados. Las comparaciones son un indicador clave del costo computacional bajo el modelo de comparación.</p>
<hr>
</section>
<section id="conjunto-a-1" class="level3">
<h3 class="anchored" data-anchor-id="conjunto-a-1">Conjunto A</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 30%">
<col style="width: 11%">
<col style="width: 27%">
<col style="width: 13%">
</colgroup>
<thead>
<tr class="header">
<th>Algoritmo</th>
<th>Comparaciones Promedio</th>
<th>Mediana</th>
<th>Desviación Estándar</th>
<th>Mín – Máx</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>BK</strong></td>
<td>493</td>
<td>444</td>
<td>191</td>
<td>59 – 1180</td>
</tr>
<tr class="even">
<td><strong>BY_bis</strong></td>
<td>1361</td>
<td>1353</td>
<td>165</td>
<td>1068 – 1865</td>
</tr>
<tr class="odd">
<td><strong>BY_B2</strong></td>
<td>2411</td>
<td>2367</td>
<td>455</td>
<td>1173 – 3831</td>
</tr>
<tr class="even">
<td><strong>BY_B1</strong></td>
<td>2493</td>
<td>2472</td>
<td>324</td>
<td>1926 – 3422</td>
</tr>
<tr class="odd">
<td><strong>ME</strong></td>
<td>9128</td>
<td>4574</td>
<td>10654</td>
<td>3152 – 42392</td>
</tr>
</tbody>
</table>
<p><strong>Observación:</strong> El algoritmo <strong>BK</strong> es claramente el más eficiente en comparaciones, con una media significativamente menor. <strong>ME</strong> destaca negativamente con una alta media y dispersión, lo que lo vuelve poco recomendable. Las variantes de <strong>BY</strong> son intermedias, siendo <strong>BY_bis</strong> la más favorable de ellas.</p>
<hr>
</section>
<section id="conjunto-b-1" class="level3">
<h3 class="anchored" data-anchor-id="conjunto-b-1">Conjunto B</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 30%">
<col style="width: 11%">
<col style="width: 27%">
<col style="width: 13%">
</colgroup>
<thead>
<tr class="header">
<th>Algoritmo</th>
<th>Comparaciones Promedio</th>
<th>Mediana</th>
<th>Desviación Estándar</th>
<th>Mín – Máx</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>BK</strong></td>
<td>1233</td>
<td>1085</td>
<td>405</td>
<td>346 – 2376</td>
</tr>
<tr class="even">
<td><strong>BY_bis</strong></td>
<td>2805</td>
<td>2751</td>
<td>241</td>
<td>2222 – 3384</td>
</tr>
<tr class="odd">
<td><strong>BY_B2</strong></td>
<td>4951</td>
<td>4762</td>
<td>662</td>
<td>3223 – 6582</td>
</tr>
<tr class="even">
<td><strong>BY_B1</strong></td>
<td>5374</td>
<td>5161</td>
<td>780</td>
<td>3833 – 7358</td>
</tr>
<tr class="odd">
<td><strong>ME</strong></td>
<td>18321</td>
<td>12888</td>
<td>17246</td>
<td>4417 – 85447</td>
</tr>
</tbody>
</table>
<p><strong>Observación:</strong> El comportamiento observado se mantiene: <strong>BK</strong> requiere muchas menos comparaciones que cualquier otro algoritmo. A medida que aumenta la complejidad del conjunto, <strong>ME</strong> se vuelve aún menos eficiente, con un rango de comparaciones extremadamente amplio.</p>
<hr>
</section>
<section id="conjunto-c-1" class="level3">
<h3 class="anchored" data-anchor-id="conjunto-c-1">Conjunto C</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 30%">
<col style="width: 11%">
<col style="width: 27%">
<col style="width: 13%">
</colgroup>
<thead>
<tr class="header">
<th>Algoritmo</th>
<th>Comparaciones Promedio</th>
<th>Mediana</th>
<th>Desviación Estándar</th>
<th>Mín – Máx</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>BK</strong></td>
<td>1602</td>
<td>1493</td>
<td>375</td>
<td>840 – 3017</td>
</tr>
<tr class="even">
<td><strong>BY_bis</strong></td>
<td>3808</td>
<td>3691</td>
<td>327</td>
<td>3002 – 4662</td>
</tr>
<tr class="odd">
<td><strong>BY_B2</strong></td>
<td>6520</td>
<td>6324</td>
<td>698</td>
<td>4539 – 8401</td>
</tr>
<tr class="even">
<td><strong>BY_B1</strong></td>
<td>7105</td>
<td>6842</td>
<td>870</td>
<td>5114 – 9369</td>
</tr>
<tr class="odd">
<td><strong>ME</strong></td>
<td>21521</td>
<td>14518</td>
<td>16510</td>
<td>5406 – 56670</td>
</tr>
</tbody>
</table>
<p><strong>Observación:</strong> En conjuntos más extensos (tetrapletas), el patrón se acentúa. <strong>BK</strong> sigue siendo el algoritmo más parsimonioso en comparaciones. Las estrategias más adaptativas como <strong>BY_B2</strong> y <strong>BY_B1</strong> incrementan su costo. <strong>ME</strong> alcanza un comportamiento fuertemente ineficiente y errático.</p>
<hr>
</section>
<section id="observaciones-generales-1" class="level3">
<h3 class="anchored" data-anchor-id="observaciones-generales-1">Observaciones Generales</h3>
<ul>
<li><p><strong>BK (Barbay &amp; Kenyon)</strong> domina en todos los conjuntos al requerir el menor número de comparaciones, mostrando excelente adaptabilidad y eficiencia.</p></li>
<li><p><strong>BY_bis</strong> es un buen compromiso entre simplicidad y rendimiento, siendo superior a <strong>BY_B1</strong> y <strong>BY_B2</strong>, que son más costosos en este modelo.</p></li>
<li><p><strong>ME (Melding)</strong> es el algoritmo menos eficiente, presentando altos valores medios y desviaciones grandes en todos los conjuntos. Esto lo hace poco adecuado para entornos sensibles al costo de comparación.</p></li>
<li><p>El incremento en el número de listas por conjunto (de pares a tetrapletas) incrementa naturalmente las comparaciones, pero <strong>BK</strong> logra escalar con gracia en contraste con los demás algoritmos.</p></li>
</ul>
</section>
</section>
<section id="boxplot-de-longitudes-de-intersección-como-métrica-de-control" class="level2">
<h2 class="anchored" data-anchor-id="boxplot-de-longitudes-de-intersección-como-métrica-de-control"><strong>Boxplot de Longitudes de Intersección como Métrica de Control</strong></h2>
<p>En esta sección se presentan diagramas de caja que muestran la distribución de las longitudes de las intersecciones generadas por cada algoritmo. Esta métrica actúa como un control de consistencia para validar que los resultados producidos por cada método sean comparables entre sí y reflejen la correcta implementación del proceso de intersección.</p>
<div id="5Uir41BK07G5" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:607}}" data-outputid="5b5c5415-a06c-4ca0-9495-c1da7375b222" data-execution_count="70">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Gráfico boxplot de la longitud de intersección por conjunto y algoritmo</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>sns.boxplot(</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    data<span class="op">=</span>df,</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span><span class="st">"conjunto"</span>,         <span class="co"># Conjuntos A, B, C</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="st">"long_inter"</span>,       <span class="co"># Métrica: longitud de intersección</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    hue<span class="op">=</span><span class="st">"algoritmo"</span>       <span class="co"># Agrupación por algoritmo</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Longitud de Intersección por Algoritmo y Conjunto"</span>)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Conjunto de prueba"</span>)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Tamaño de la Intersección"</span>)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>plt.legend(title<span class="op">=</span><span class="st">"Algoritmo"</span>)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="SegundoDavid_U5_T1_files/figure-html/cell-18-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="análisis-de-longitudes-de-intersección" class="level3">
<h3 class="anchored" data-anchor-id="análisis-de-longitudes-de-intersección"><strong>Análisis de Longitudes de Intersección</strong></h3>
<p>Este análisis examina las longitudes de intersección obtenidas por los distintos algoritmos sobre los conjuntos A, B y C. Esta métrica permite verificar que los algoritmos están produciendo resultados consistentes y comparables, actuando como mecanismo de control para validar la calidad de la intersección.</p>
<hr>
</section>
<section id="conjunto-a-2" class="level3">
<h3 class="anchored" data-anchor-id="conjunto-a-2">Conjunto A</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Algoritmo</th>
<th>Promedio</th>
<th>Mediana</th>
<th>Máximo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>BY_B1</strong></td>
<td>111.6</td>
<td>111</td>
<td>126</td>
</tr>
<tr class="even">
<td><strong>BY_bis</strong></td>
<td>20.2</td>
<td>15</td>
<td>59</td>
</tr>
<tr class="odd">
<td><strong>BY_B2</strong></td>
<td>20.1</td>
<td>14</td>
<td>64</td>
</tr>
<tr class="even">
<td><strong>ME</strong></td>
<td>19.6</td>
<td>14</td>
<td>61</td>
</tr>
<tr class="odd">
<td><strong>BK</strong></td>
<td>2.8</td>
<td>1</td>
<td>24</td>
</tr>
</tbody>
</table>
<p><strong>Observación:</strong> El algoritmo <strong>BY_B1</strong> muestra consistentemente las intersecciones más largas, lo que sugiere un comportamiento diferente en la lógica de intersección. Esto puede deberse a una menor precisión o mayor permisividad en su método de comparación. <strong>BK</strong> y <strong>ME</strong> presentan resultados más compactos y conservadores.</p>
<hr>
</section>
<section id="conjunto-b-2" class="level3">
<h3 class="anchored" data-anchor-id="conjunto-b-2">Conjunto B</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Algoritmo</th>
<th>Promedio</th>
<th>Mediana</th>
<th>Máximo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>BY_B1</strong></td>
<td>189.7</td>
<td>188</td>
<td>263</td>
</tr>
<tr class="even">
<td><strong>BY_bis</strong></td>
<td>25.0</td>
<td>17</td>
<td>93</td>
</tr>
<tr class="odd">
<td><strong>BY_B2</strong></td>
<td>25.1</td>
<td>16</td>
<td>92</td>
</tr>
<tr class="even">
<td><strong>ME</strong></td>
<td>23.6</td>
<td>15</td>
<td>86</td>
</tr>
<tr class="odd">
<td><strong>BK</strong></td>
<td>3.4</td>
<td>2</td>
<td>25</td>
</tr>
</tbody>
</table>
<p><strong>Observación:</strong> Nuevamente, <strong>BY_B1</strong> genera longitudes de intersección significativamente mayores, lo que refuerza la hipótesis de que su lógica puede ser menos estricta. <strong>BK</strong> se mantiene como el más estricto, produciendo las intersecciones más pequeñas de manera sistemática.</p>
<hr>
</section>
<section id="conjunto-c-2" class="level3">
<h3 class="anchored" data-anchor-id="conjunto-c-2">Conjunto C</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Algoritmo</th>
<th>Promedio</th>
<th>Mediana</th>
<th>Máximo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>BY_B1</strong></td>
<td>112.0</td>
<td>111</td>
<td>128</td>
</tr>
<tr class="even">
<td><strong>BY_bis</strong></td>
<td>9.2</td>
<td>4</td>
<td>81</td>
</tr>
<tr class="odd">
<td><strong>ME</strong></td>
<td>7.8</td>
<td>3</td>
<td>70</td>
</tr>
<tr class="even">
<td><strong>BY_B2</strong></td>
<td>7.7</td>
<td>3</td>
<td>70</td>
</tr>
<tr class="odd">
<td><strong>BK</strong></td>
<td>0.18</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><strong>Observación:</strong> El patrón se mantiene constante. <strong>BY_B1</strong> genera longitudes altas incluso en conjuntos de mayor cardinalidad. <strong>BK</strong>, en contraste, produce intersecciones casi nulas en muchos casos, lo que puede estar relacionado con una política de comparación más conservadora.</p>
<hr>
</section>
</section>
<section id="observaciones-generales-2" class="level2">
<h2 class="anchored" data-anchor-id="observaciones-generales-2">Observaciones Generales</h2>
<ul>
<li><p><strong>BY_B1</strong> es el algoritmo que produce sistemáticamente las longitudes de intersección más altas en los tres conjuntos, lo que sugiere un enfoque más permisivo o amplio en su proceso de coincidencia.</p></li>
<li><p>Los algoritmos <strong>BY_bis</strong>, <strong>BY_B2</strong> y <strong>ME</strong> mantienen valores similares entre sí, con intersecciones moderadas, mostrando un balance razonable entre precisión y cobertura.</p></li>
<li><p><strong>BK</strong> genera los resultados más conservadores en todos los conjuntos, con intersecciones muy reducidas o incluso nulas, lo que podría indicar mayor precisión a costa de menor recall.</p></li>
<li><p>En general, las longitudes de intersección permiten validar la coherencia de los algoritmos: aquellos con menor número de comparaciones tienden a ser más estrictos en coincidencias, mientras que los más exhaustivos ofrecen mayor cobertura, aunque con mayor costo computacional.</p></li>
</ul>
<hr>
</section>
</section>
<section id="conclusiones-generales" class="level1">
<h1><strong>Conclusiones Generales</strong></h1>
<section id="gráficos" class="level3">
<h3 class="anchored" data-anchor-id="gráficos">Gráficos</h3>
<ul>
<li><p><strong>BK (Barbay &amp; Kenyon)</strong> se consolida como la opción más robusta y estable frente a distintos tamaños y configuraciones de entrada. Sus tiempos de ejecución y número de comparaciones son consistentemente bajos, con una dispersión mínima en los tres conjuntos (A, B, y C). Esto refleja la eficacia de su enfoque adaptativo con memoria de posición previa, que reduce drásticamente el costo de comparación sin sacrificar precisión. El rendimiento de BK lo convierte en una solución idónea para sistemas que requieren eficiencia y previsibilidad, como motores de búsqueda y sistemas de recuperación de información.</p></li>
<li><p><strong>ME (Melding)</strong>, si bien es intuitivo y fácil de implementar gracias a su escaneo secuencial de punteros, evidencia un crecimiento rápido tanto en tiempo de ejecución como en comparaciones a medida que aumentan el número y la longitud de las listas. Esto se manifiesta particularmente en los conjuntos B y C, donde alcanza máximos notorios en las tres métricas. Aunque su desempeño lo hace poco escalable, puede resultar útil como base de comparación o para entornos muy controlados.</p></li>
<li><p>Las variantes de <strong>Baeza-Yates (BY)</strong> permiten modular la estrategia según el tipo de datos:</p>
<ul>
<li><strong>BY_B1</strong> (búsqueda exponencial seguida de binaria) sobresale en la detección de intersecciones grandes. Su capacidad para escalar con eficiencia cuando el primer conjunto es pequeño le permite alcanzar las longitudes de intersección más altas sin comprometer demasiado el tiempo.</li>
<li><strong>BY_bis</strong>, al utilizar búsqueda binaria clásica, resulta ideal para listas equilibradas. Muestra tiempos de ejecución bajos y estables, siendo comparable con BK en eficiencia, aunque su cobertura de intersecciones es menor.</li>
<li><strong>BY_B2</strong>, con su estrategia doblemente exponencial, ofrece cierta escalabilidad con saltos agresivos, pero esto viene acompañado de un riesgo: en escenarios desbalanceados, produce valores atípicos (outliers) con altos costos de comparación y tiempo.</li>
</ul></li>
<li><p>Se vislumbra una oportunidad interesante en estrategias híbridas: por ejemplo, utilizar <strong>BK para filtrar candidatos</strong> y posteriormente aplicar <strong>BY_B1 o BY_B2 para refinar</strong>. Este enfoque podría combinar la eficiencia de BK con la capacidad de cobertura profunda de las variantes de BY, especialmente en dominios como recuperación de documentos, detección de patrones o sistemas de recomendación.</p></li>
</ul>
<hr>
</section>
<section id="tabla-y-métricas" class="level3">
<h3 class="anchored" data-anchor-id="tabla-y-métricas">Tabla y Métricas</h3>
<ul>
<li><p><strong>BK</strong> destaca como el algoritmo más eficiente globalmente:</p>
<ul>
<li>Promedios más bajos en tiempo y comparaciones en los tres conjuntos.</li>
<li>Baja varianza, lo cual refleja un comportamiento consistente ante diferentes distribuciones de datos.</li>
<li>Ideal para producción en tiempo real, gracias a su predictibilidad y rendimiento estable.</li>
</ul></li>
<li><p><strong>ME</strong> refleja limitaciones importantes:</p>
<ul>
<li>Sus valores medios y máximos en tiempo y comparaciones son los más altos del conjunto.</li>
<li>Muestra fuerte dispersión, lo que indica una pobre adaptación a cambios en el volumen o estructura de las listas.</li>
<li>No es recomendable para aplicaciones a gran escala.</li>
</ul></li>
<li><p><strong>BY_B2</strong> demuestra potencial cuando se dispone de datos bien distribuidos y se busca profundidad, pero sus costos extremos en algunas instancias comprometen su fiabilidad general. La alta desviación estándar lo posiciona como una opción con riesgos en entornos donde se requiere consistencia.</p></li>
<li><p><strong>BY_B1 y BY_bis</strong> representan compromisos efectivos:</p>
<ul>
<li><strong>BY_B1</strong> ofrece la mejor cobertura en intersecciones largas, especialmente en conjunto B.</li>
<li><strong>BY_bis</strong> logra tiempos y comparaciones reducidas cuando los conjuntos están bien balanceados.</li>
<li>Ambos mantienen una dispersión moderada y son adecuados para aplicaciones prácticas con presupuestos computacionales limitados.</li>
</ul></li>
</ul>
<hr>
</section>
<section id="síntesis-final" class="level3">
<h3 class="anchored" data-anchor-id="síntesis-final">Síntesis Final</h3>
<p>El estudio confirma que no existe un único algoritmo óptimo para todos los escenarios, pero <strong>BK</strong> emerge como el candidato más versátil por su bajo costo y estabilidad. <strong>BY_B1</strong> ofrece la mejor cobertura cuando la prioridad es capturar intersecciones completas, mientras que <strong>BY_bis</strong> y <strong>BY_B2</strong> ofrecen alternativas viables según la estructura del problema. <strong>ME</strong>, aunque funcional, queda relegado a contextos educativos o demostrativos debido a su pobre escalabilidad.</p>
<hr>
</section>
</section>
<section id="referencias" class="level1">
<h1><strong>Referencias</strong></h1>
<ul>
<li>Baeza-Yates, R. (2004). <em>Efficient Text Searching</em>. In: Algorithms and Applications.</li>
<li>Barbay, J., López-Ortiz, A., &amp; Lu, T. (2006). <em>Faster Adaptive Set Intersections</em>. In: Experimental Algorithms.</li>
<li>Demaine, E. D., López-Ortiz, A., &amp; Munro, J. I. (2001). <em>Adaptive Set Intersections, Unions, and Differences</em>. In: SODA.</li>
<li>Hwang, F. K., &amp; Lin, S. (1971). <em>A linear-time algorithm for merging two sorted arrays</em>. In: ACM Transactions.</li>
<li>MacKay, D. J. C. (2003). <em>Information Theory, Inference, and Learning Algorithms</em>. Cambridge University Press.</li>
</ul>
<hr>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/DavidSG24\.github\.io\/An-lisis-de-algoritmos\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>