{"title":"**Introducción**","markdown":{"headingText":"**Introducción**","containsRefs":false,"markdown":"\n<h1><b>Práctica: Algoritmos de intersección y unión de conjuntos en el modelo de comparación</b></h1>\n\n<h1><b>Alumno: David Segundo Garcia</b></h1>\n\n----\n\n\n\n\n**Análisis Comparativo de Algoritmos de Intersección de Conjuntos**\n\nEste estudio evalúa y compara el desempeño de varios algoritmos diseñados para resolver el problema de la intersección de conjuntos ordenados, un problema fundamental en estructuras como los índices invertidos y sistemas de recuperación de información (Hwang & Lin, 1971). En dichos contextos, los conjuntos se representan frecuentemente como listas ordenadas de enteros, lo cual permite aplicar algoritmos especializados de búsqueda y comparación.\n\nSe implementaron y analizaron las siguientes estrategias algorítmicas:\n\n* **Melding (ME)**: basado en el escaneo secuencial de punteros para conjuntos ordenados.\n* **Baeza-Yates (BY)** con variantes de búsqueda interna:\n\n  * **Bisección (BY\\_bis)**: búsqueda binaria clásica.\n  * **Búsqueda exponencial (BY\\_B1)**: óptima cuando los tamaños de los conjuntos son muy distintos.\n  * **Búsqueda doblemente exponencial (BY\\_B2)**: adaptativa, eficiente al aprovechar información previa.\n* **Barbay & Kenyon (BK)**: enfoque adaptativo que memoriza posiciones previamente exploradas para acelerar búsquedas subsecuentes.\n\nEstos algoritmos surgen como solución al problema de determinar eficientemente la intersección entre listas ordenadas, minimizando el número de comparaciones y el uso de memoria. En particular, el algoritmo de Baeza-Yates aplica una estrategia de **divide y vencerás** al buscar la mediana del primer conjunto dentro del segundo y dividir el problema en subproblemas más pequeños (Baeza-Yates, 2004). Por otro lado, el algoritmo de Barbay y Kenyon (2006) emplea búsquedas adaptativas para aprovechar concentraciones locales y reducir trabajo redundante. Ambos algoritmos están diseñados para ser óptimos incluso en el peor caso.\n\nAdemás, se consideran técnicas como **merge** (fusión secuencial) para listas de tamaño similar, y estrategias como **Small vs Small (SvS)** para intersecciones entre múltiples conjuntos, que consisten en intersectar los subconjuntos más pequeños primero, obteniendo así ganancias de eficiencia (Demaine et al., 2001).\n\n---\n\n### **Metodología de Evaluación**\n\nLos algoritmos fueron evaluados experimentalmente sobre tres tipos de conjuntos:\n\n* **Conjunto A**: pares de listas ordenadas.\n* **Conjunto B**: tripletas de listas ordenadas.\n* **Conjunto C**: tetrapletas (cuádruples) de listas ordenadas.\n\nPara cada algoritmo y conjunto se midieron tres métricas clave:\n\n* **Tiempo de ejecución** (en segundos)\n* **Número de comparaciones realizadas** (costo en el modelo de comparación)\n* **Tamaño de la intersección resultante** (control de consistencia)\n\nEstos resultados permiten contrastar la **eficiencia algorítmica** bajo distintas configuraciones de entrada, diferenciando entre comportamientos óptimos y degenerados. Además, se tomaron en cuenta los modelos de costo teóricos, como el modelo de comparación, donde el número mínimo de comparaciones requeridas para unir dos conjuntos de tamaños $m$ y $n$ se aproxima por $\\log_2\\binom{m+n}{m}$ (Hwang & Lin, 1971; MacKay, 2003), y los escenarios donde $m \\ll n$, que justifican el uso de búsquedas binarias para mejorar la eficiencia a $O(m \\log n)$.\n\n----\n\n# **Instrucciones**\n\n1. **Lea** el archivo de datos provisto, el cual se encuentra en formato JSON, y contiene múltiples listas de datos:\n\n   * Conjunto **A** que contiene pares de listas.\n   * Conjunto **B** que contiene tripletas de listas.\n   * Conjunto **C** que contiene tuplas de 4 listas (tetrapleta).\n\n2. **Implementación de Algoritmos**:\n\n   * **Implemente** los algoritmos de Melding (ME), Baeza-Yates (BY) y de Barbay & Kenyon (BK).\n   * **Implemente** BY parametrizando con algoritmos de búsqueda: bisección, y búsqueda no acotada B1 y B2 (ver Unidad 4).\n\n3. **Experimentación**:\n\n   * **Calcule** las intersecciones para los datos de cada grupo de listas (A, B y C).\n   * **Acumule** el tiempo en segundos y el número de comparaciones para cada operación. Es posible que necesite repetir varias veces el procedimiento para medir tiempos de manera fiable.\n   * **Cree** gráficos boxplot para cada conjunto de listas con los siguientes aspectos, incluya en cada gráfica todos los algoritmos para que sean fáciles de comparar:\n\n     * Tiempo en segundos de los tres experimentos, por algoritmo.\n     * Número de comparaciones de los tres experimentos, por algoritmo.\n     * Longitudes de las intersecciones resultantes para A, B, C. Este también es un gráfico de control, úselo para detectar posibles errores.\n\n4. **Análisis**:\n\n   * **Analice** los resultados obtenidos en los gráficos boxplot. Examine las diferencias en tiempo, número de comparaciones y longitud de las intersecciones entre los distintos algoritmos y conjuntos de listas.\n   * **Discuta** cualquier tendencia, anomalía o patrón interesante observado. Reflexione sobre cómo los diferentes algoritmos afectan el rendimiento y la eficiencia en las operaciones de intersección.\n\n---\n\n\n# <h1><b>Solución</b></h1>\n\n## **Definimos las librerías que usaremos:**\n\n## **Carga de archivos para iniciar procesamiento**\n\nEste bloque de código carga tres conjuntos de datos en formato JSON que contienen listas ordenadas para experimentos de intersección de conjuntos. Primero define las rutas a los archivos correspondientes a los conjuntos A (pares), B (tripletas) y C (tetrapletas), luego utiliza una función para leer cada archivo y cargar su contenido en memoria. Si algún archivo no se encuentra, muestra una advertencia. Finalmente, imprime cuántas instancias hay en cada conjunto y asigna los datos a variables individuales (`dataset_a`, `dataset_b`, `dataset_c`) para su uso posterior en la evaluación de algoritmos.\n\n\n# **Implementación y Descripción Técnica de los Algoritmos**\n\nEste código define una clase llamada `ComparisonCounter` que permite contar cuántas comparaciones se realizan durante la ejecución de algoritmos de intersección de conjuntos. La clase incluye métodos para comparar dos valores y reiniciar el contador. Además, se define una función `load_datasets` que carga desde un archivo JSON tres conjuntos de datos etiquetados como A, B y C, y los retorna por separado para su procesamiento posterior.\n\n\n## **Algoritmos de búsqueda**\n\n### **Función de búsqueda binaria**\n\nEsta función implementa una **búsqueda binaria instrumentada**, que busca un elemento `x` dentro de una lista ordenada `arr`, mientras **registra el número de comparaciones** realizadas mediante un objeto `ComparisonCounter`. Devuelve el índice donde se encuentra `x`, o `-1` si no está presente.\n\n\n### **Dobling search (B1)**\n\nEsta función realiza una **búsqueda exponencial seguida de una búsqueda binaria** para localizar un elemento `x` en una lista ordenada `arr`, comenzando desde una posición inicial `start`. Usa un contador (`ComparisonCounter`) para registrar las comparaciones realizadas. Si encuentra el elemento, retorna su índice; si no, devuelve la posición donde se debería insertar (`upper bound`).\n\n\n### **Búsqueda B2 (doble doubling)**\n\nEsta función implementa la búsqueda B2, que consiste en un **doble salto exponencial** para encontrar un rango adecuado y luego una **búsqueda exponencial interna** (con binaria incluida) para localizar un elemento `x` en una lista ordenada `arr`. Utiliza un `ComparisonCounter` para contar comparaciones y devuelve el índice de `x` si se encuentra, o su posición de inserción si no.\n\n\n## **Algoritmos de intersección**\n\n### **Melding Intersection (ME)**\n\nEsta función implementa el algoritmo **Melding (ME)** para calcular la intersección de múltiples listas ordenadas. Utiliza punteros sincronizados para comparar los elementos actuales de cada lista y avanzar solo aquellos que aún no alcanzan el valor máximo observado. Si todos coinciden, el valor se agrega a la intersección. Usa un `ComparisonCounter` para registrar el número de comparaciones realizadas, y retorna tanto la lista resultante como ese conteo.\n\n\n### **Baeza-Yates**\n\nEsta función implementa el algoritmo Baeza-Yates utilizando búsqueda binaria instrumentada para calcular la intersección de varias listas ordenadas. Ordena las listas de menor a mayor para reducir el número de comparaciones, luego busca cada elemento del conjunto más pequeño en los demás. Usa un ComparisonCounter para registrar las comparaciones realizadas y devuelve tanto la intersección resultante como el conteo total de comparaciones.\n\n### **Baeza-Yates con búsqueda exponencial**\n\nEsta función implementa la variante **B1 del algoritmo Baeza-Yates**, que utiliza **búsqueda exponencial** para encontrar un elemento en múltiples listas ordenadas. Para cada elemento del conjunto más pequeño, verifica si está presente en los demás conjuntos usando `exponential_binary_search`. Registra las comparaciones mediante un `ComparisonCounter` y retorna la intersección obtenida junto con el número total de comparaciones realizadas.\n\n\n### **Baeza-Yates con búsqueda exponencial (B2)**\n\nEsta función implementa la variante **B2 del algoritmo Baeza-Yates**, que utiliza una **búsqueda doblemente exponencial** para calcular la intersección de listas ordenadas. Optimiza el proceso guardando la última posición de búsqueda en cada lista, evitando comenzar desde el inicio cada vez. Usa un `ComparisonCounter` para registrar comparaciones y retorna la lista de elementos comunes junto con el total de comparaciones realizadas.\n\n\n### **Barbay & Kenyon (BK)**\n\nEsta función implementa el algoritmo **Barbay & Kenyon (BK)** para calcular la intersección de múltiples listas ordenadas. Utiliza una estrategia **adaptativa**, donde cada lista busca un candidato común utilizando una función de búsqueda eficiente (por defecto, búsqueda exponencial). Los punteros se actualizan dinámicamente para evitar retrocesos, y se registra el número total de comparaciones con un `ComparisonCounter`. La función devuelve la intersección resultante y el número total de comparaciones realizadas.\n\n\n---\n\n# **Desarrollo del Experimento**\n\nPara evaluar el comportamiento de cada algoritmo, se desarrollaron funciones que permiten ejecutar y registrar su rendimiento sobre distintos tipos de conjuntos. Específicamente, se midieron tres métricas fundamentales para cada algoritmo y conjunto:\n\n* **Tiempo de ejecución** (en segundos).\n* **Número de comparaciones realizadas** (en el modelo de comparación).\n* **Tamaño de la intersección resultante** (como control de consistencia).\n\nEstos datos permiten analizar de forma cuantitativa la eficiencia algorítmica bajo diferentes configuraciones de entrada.\n\n\n\n## **Conversión de Resultados a Formato Tabular**\n\nUna vez obtenidas las métricas de evaluación, se procede a transformar los resultados en una estructura tabular para facilitar su análisis. Para ello, se construye un DataFrame plano en el que cada fila representa una combinación de algoritmo y conjunto de datos, junto con sus respectivas métricas:\n\n* **Algoritmo aplicado**\n* **Tipo de conjunto** (A, B o C)\n* **Tiempo de ejecución**\n* **Número de comparaciones realizadas**\n* **Longitud de la intersección obtenida**\n\nEsta representación permite comparar el comportamiento de los algoritmos de forma clara y sistemática a lo largo de distintas configuraciones experimentales.\n\n\n----\n\nCon el objetivo de comparar de manera clara y estructurada el comportamiento de los distintos algoritmos de intersección, se generarán visualizaciones que resumen su rendimiento sobre los conjuntos de datos evaluados. En particular, se utilizarán diagramas de caja para analizar las siguientes métricas clave:\n\n* **Tiempo de ejecución**\n* **Número de comparaciones realizadas**\n* **Tamaño de la intersección obtenida**\n\nEstas representaciones permitirán identificar patrones, anomalías y diferencias de eficiencia entre algoritmos bajo diversas configuraciones de entrada.\n\n\n## **Boxplot de Tiempos de Ejecución por Algoritmo y Conjunto**\n\nEste gráfico compara el rendimiento temporal de los algoritmos aplicados sobre los conjuntos A, B y C. El tiempo de ejecución, medido en segundos, permite evaluar la eficiencia computacional de cada método bajo distintas configuraciones de entrada. Esta métrica es fundamental para identificar algoritmos escalables y con buen desempeño práctico.\n\n\n### **Análisis de Tiempos de Ejecución**\n\nA continuación se presentan las observaciones derivadas del análisis estadístico y visualización de tiempos de ejecución para los algoritmos evaluados en los tres conjuntos de datos.\n\n---\n\n### Conjunto A\n\n| Algoritmo   | Media (s) | Desviación estándar | Mediana (s) | Mín – Máx (s)         |\n|-------------|-----------|----------------------|-------------|------------------------|\n| **BK**      | 0.00035   | 0.00030              | 0.00028     | 0.00005 – 0.00337      |\n| **BY_bis**  | 0.00067   | 0.00015              | 0.00064     | 0.00050 – 0.00217      |\n| **BY_B1**   | 0.00118   | 0.00034              | 0.00112     | 0.00087 – 0.00481      |\n| **BY_B2**   | 0.00126   | 0.00044              | 0.00118     | 0.00061 – 0.00446      |\n| **ME**      | 0.00267   | 0.00259              | 0.00153     | 0.00102 – 0.01116      |\n\n**Observación:** El algoritmo **BK** es el más rápido y consistente, mientras que **ME** muestra el peor rendimiento. Las variantes de Baeza-Yates tienen buen desempeño, destacando **BY_bis** como el mejor entre ellas.\n\n---\n\n### Conjunto B\n\n| Algoritmo   | Media (s) | Desviación estándar | Mediana (s) | Mín – Máx (s)         |\n|-------------|-----------|----------------------|-------------|------------------------|\n| **BK**      | 0.00066   | 0.00040              | 0.00055     | 0.00019 – 0.00461      |\n| **BY_bis**  | 0.00091   | 0.00019              | 0.00088     | 0.00060 – 0.00163      |\n| **BY_B2**   | 0.00134   | 0.00033              | 0.00125     | 0.00088 – 0.00288      |\n| **BY_B1**   | 0.00146   | 0.00037              | 0.00137     | 0.00100 – 0.00294      |\n| **ME**      | 0.00446   | 0.00416              | 0.00287     | 0.00126 – 0.01725      |\n\n**Observación:** Nuevamente, **BK** lidera en eficiencia, con **BY_bis** como opción viable. **ME** se vuelve más ineficiente conforme aumentan el tamaño y cantidad de listas, reflejado en su alta media y dispersión.\n\n---\n\n### Conjunto C\n\n| Algoritmo   | Media (s) | Desviación estándar | Mediana (s) | Mín – Máx (s)         |\n|-------------|-----------|----------------------|-------------|------------------------|\n| **BK**      | 0.00049   | 0.00024              | 0.00043     | 0.00019 – 0.00202      |\n| **BY_B2**   | 0.00086   | 0.00027              | 0.00080     | 0.00046 – 0.00176      |\n| **BY_bis**  | 0.00087   | 0.00018              | 0.00084     | 0.00060 – 0.00144      |\n| **BY_B1**   | 0.00110   | 0.00035              | 0.00104     | 0.00074 – 0.00269      |\n| **ME**      | 0.00291   | 0.00194              | 0.00251     | 0.00132 – 0.01159      |\n\n**Observación:** A pesar del aumento en la complejidad de las tuplas, **BK** se mantiene como el más rápido. **BY_B2** mejora su rendimiento relativo gracias a su adaptabilidad. **ME** conserva su patrón de bajo rendimiento.\n\n---\n\n### Observaciones Generales\n\n- **BK (Barbay & Kenyon)** es el algoritmo más eficiente y estable en todos los conjuntos. Su comportamiento adaptativo lo hace ideal para conjuntos ordenados de cualquier tamaño o complejidad.\n\n- **BY_bis** ofrece una excelente relación entre simplicidad y rendimiento, siendo una alternativa práctica especialmente en casos donde no se requiere adaptabilidad compleja.\n\n- Las variantes **BY_B1** y **BY_B2** muestran mejoras en conjuntos más grandes, aunque con mayor costo computacional.\n\n- **ME (Melding)** es el menos eficiente en todos los escenarios. Aunque sencillo, su estrategia de escaneo secuencial no escala bien con el número de listas ni con su longitud.\n\n---\n\n\n\n## **Boxplot del Número de Comparaciones por Algoritmo y Conjunto**\n\nEsta visualización permite comparar la eficiencia computacional de los algoritmos evaluados, midiendo el número de comparaciones realizadas durante el proceso de intersección en los conjuntos A, B y C. Una menor cantidad de comparaciones sugiere un algoritmo más eficiente en términos de operaciones internas, sin comprometer necesariamente la calidad del resultado.\n\n\n### **Análisis de Comparaciones**\n\nEste análisis examina el número de comparaciones realizadas por cada algoritmo durante las operaciones de intersección de conjuntos ordenados. Las comparaciones son un indicador clave del costo computacional bajo el modelo de comparación.\n\n---\n\n### Conjunto A\n\n| Algoritmo   | Comparaciones Promedio | Mediana | Desviación Estándar | Mín – Máx |\n|-------------|------------------------|---------|----------------------|-----------|\n| **BK**      | 493                    | 444     | 191                  | 59 – 1180 |\n| **BY_bis**  | 1361                   | 1353    | 165                  | 1068 – 1865 |\n| **BY_B2**   | 2411                   | 2367    | 455                  | 1173 – 3831 |\n| **BY_B1**   | 2493                   | 2472    | 324                  | 1926 – 3422 |\n| **ME**      | 9128                   | 4574    | 10654                | 3152 – 42392 |\n\n**Observación:** El algoritmo **BK** es claramente el más eficiente en comparaciones, con una media significativamente menor. **ME** destaca negativamente con una alta media y dispersión, lo que lo vuelve poco recomendable. Las variantes de **BY** son intermedias, siendo **BY_bis** la más favorable de ellas.\n\n---\n\n### Conjunto B\n\n| Algoritmo   | Comparaciones Promedio | Mediana | Desviación Estándar | Mín – Máx |\n|-------------|------------------------|---------|----------------------|-----------|\n| **BK**      | 1233                   | 1085    | 405                  | 346 – 2376 |\n| **BY_bis**  | 2805                   | 2751    | 241                  | 2222 – 3384 |\n| **BY_B2**   | 4951                   | 4762    | 662                  | 3223 – 6582 |\n| **BY_B1**   | 5374                   | 5161    | 780                  | 3833 – 7358 |\n| **ME**      | 18321                  | 12888   | 17246                | 4417 – 85447 |\n\n**Observación:** El comportamiento observado se mantiene: **BK** requiere muchas menos comparaciones que cualquier otro algoritmo. A medida que aumenta la complejidad del conjunto, **ME** se vuelve aún menos eficiente, con un rango de comparaciones extremadamente amplio.\n\n---\n\n### Conjunto C\n\n| Algoritmo   | Comparaciones Promedio | Mediana | Desviación Estándar | Mín – Máx |\n|-------------|------------------------|---------|----------------------|-----------|\n| **BK**      | 1602                   | 1493    | 375                  | 840 – 3017 |\n| **BY_bis**  | 3808                   | 3691    | 327                  | 3002 – 4662 |\n| **BY_B2**   | 6520                   | 6324    | 698                  | 4539 – 8401 |\n| **BY_B1**   | 7105                   | 6842    | 870                  | 5114 – 9369 |\n| **ME**      | 21521                  | 14518   | 16510                | 5406 – 56670 |\n\n**Observación:** En conjuntos más extensos (tetrapletas), el patrón se acentúa. **BK** sigue siendo el algoritmo más parsimonioso en comparaciones. Las estrategias más adaptativas como **BY_B2** y **BY_B1** incrementan su costo. **ME** alcanza un comportamiento fuertemente ineficiente y errático.\n\n---\n\n### Observaciones Generales\n\n- **BK (Barbay & Kenyon)** domina en todos los conjuntos al requerir el menor número de comparaciones, mostrando excelente adaptabilidad y eficiencia.\n\n- **BY_bis** es un buen compromiso entre simplicidad y rendimiento, siendo superior a **BY_B1** y **BY_B2**, que son más costosos en este modelo.\n\n- **ME (Melding)** es el algoritmo menos eficiente, presentando altos valores medios y desviaciones grandes en todos los conjuntos. Esto lo hace poco adecuado para entornos sensibles al costo de comparación.\n\n- El incremento en el número de listas por conjunto (de pares a tetrapletas) incrementa naturalmente las comparaciones, pero **BK** logra escalar con gracia en contraste con los demás algoritmos.\n\n\n\n## **Boxplot de Longitudes de Intersección como Métrica de Control**\n\nEn esta sección se presentan diagramas de caja que muestran la distribución de las longitudes de las intersecciones generadas por cada algoritmo. Esta métrica actúa como un control de consistencia para validar que los resultados producidos por cada método sean comparables entre sí y reflejen la correcta implementación del proceso de intersección.\n\n\n### **Análisis de Longitudes de Intersección**\n\nEste análisis examina las longitudes de intersección obtenidas por los distintos algoritmos sobre los conjuntos A, B y C. Esta métrica permite verificar que los algoritmos están produciendo resultados consistentes y comparables, actuando como mecanismo de control para validar la calidad de la intersección.\n\n---\n\n### Conjunto A\n\n| Algoritmo   | Promedio | Mediana | Máximo |\n|-------------|----------|---------|--------|\n| **BY_B1**   | 111.6    | 111     | 126    |\n| **BY_bis**  | 20.2     | 15      | 59     |\n| **BY_B2**   | 20.1     | 14      | 64     |\n| **ME**      | 19.6     | 14      | 61     |\n| **BK**      | 2.8      | 1       | 24     |\n\n**Observación:** El algoritmo **BY_B1** muestra consistentemente las intersecciones más largas, lo que sugiere un comportamiento diferente en la lógica de intersección. Esto puede deberse a una menor precisión o mayor permisividad en su método de comparación. **BK** y **ME** presentan resultados más compactos y conservadores.\n\n---\n\n### Conjunto B\n\n| Algoritmo   | Promedio | Mediana | Máximo |\n|-------------|----------|---------|--------|\n| **BY_B1**   | 189.7    | 188     | 263    |\n| **BY_bis**  | 25.0     | 17      | 93     |\n| **BY_B2**   | 25.1     | 16      | 92     |\n| **ME**      | 23.6     | 15      | 86     |\n| **BK**      | 3.4      | 2       | 25     |\n\n**Observación:** Nuevamente, **BY_B1** genera longitudes de intersección significativamente mayores, lo que refuerza la hipótesis de que su lógica puede ser menos estricta. **BK** se mantiene como el más estricto, produciendo las intersecciones más pequeñas de manera sistemática.\n\n---\n\n### Conjunto C\n\n| Algoritmo   | Promedio | Mediana | Máximo |\n|-------------|----------|---------|--------|\n| **BY_B1**   | 112.0    | 111     | 128    |\n| **BY_bis**  | 9.2      | 4       | 81     |\n| **ME**      | 7.8      | 3       | 70     |\n| **BY_B2**   | 7.7      | 3       | 70     |\n| **BK**      | 0.18     | 0       | 3      |\n\n**Observación:** El patrón se mantiene constante. **BY_B1** genera longitudes altas incluso en conjuntos de mayor cardinalidad. **BK**, en contraste, produce intersecciones casi nulas en muchos casos, lo que puede estar relacionado con una política de comparación más conservadora.\n\n---\n\n## Observaciones Generales\n\n- **BY_B1** es el algoritmo que produce sistemáticamente las longitudes de intersección más altas en los tres conjuntos, lo que sugiere un enfoque más permisivo o amplio en su proceso de coincidencia.\n\n- Los algoritmos **BY_bis**, **BY_B2** y **ME** mantienen valores similares entre sí, con intersecciones moderadas, mostrando un balance razonable entre precisión y cobertura.\n\n- **BK** genera los resultados más conservadores en todos los conjuntos, con intersecciones muy reducidas o incluso nulas, lo que podría indicar mayor precisión a costa de menor recall.\n\n- En general, las longitudes de intersección permiten validar la coherencia de los algoritmos: aquellos con menor número de comparaciones tienden a ser más estrictos en coincidencias, mientras que los más exhaustivos ofrecen mayor cobertura, aunque con mayor costo computacional.\n\n\n\n---\n\n# **Conclusiones Generales**\n\n### Gráficos\n\n* **BK (Barbay & Kenyon)** se consolida como la opción más robusta y estable frente a distintos tamaños y configuraciones de entrada. Sus tiempos de ejecución y número de comparaciones son consistentemente bajos, con una dispersión mínima en los tres conjuntos (A, B, y C). Esto refleja la eficacia de su enfoque adaptativo con memoria de posición previa, que reduce drásticamente el costo de comparación sin sacrificar precisión. El rendimiento de BK lo convierte en una solución idónea para sistemas que requieren eficiencia y previsibilidad, como motores de búsqueda y sistemas de recuperación de información.\n\n* **ME (Melding)**, si bien es intuitivo y fácil de implementar gracias a su escaneo secuencial de punteros, evidencia un crecimiento rápido tanto en tiempo de ejecución como en comparaciones a medida que aumentan el número y la longitud de las listas. Esto se manifiesta particularmente en los conjuntos B y C, donde alcanza máximos notorios en las tres métricas. Aunque su desempeño lo hace poco escalable, puede resultar útil como base de comparación o para entornos muy controlados.\n\n* Las variantes de **Baeza-Yates (BY)** permiten modular la estrategia según el tipo de datos:\n\n  * **BY\\_B1** (búsqueda exponencial seguida de binaria) sobresale en la detección de intersecciones grandes. Su capacidad para escalar con eficiencia cuando el primer conjunto es pequeño le permite alcanzar las longitudes de intersección más altas sin comprometer demasiado el tiempo.\n  * **BY\\_bis**, al utilizar búsqueda binaria clásica, resulta ideal para listas equilibradas. Muestra tiempos de ejecución bajos y estables, siendo comparable con BK en eficiencia, aunque su cobertura de intersecciones es menor.\n  * **BY\\_B2**, con su estrategia doblemente exponencial, ofrece cierta escalabilidad con saltos agresivos, pero esto viene acompañado de un riesgo: en escenarios desbalanceados, produce valores atípicos (outliers) con altos costos de comparación y tiempo.\n\n* Se vislumbra una oportunidad interesante en estrategias híbridas: por ejemplo, utilizar **BK para filtrar candidatos** y posteriormente aplicar **BY\\_B1 o BY\\_B2 para refinar**. Este enfoque podría combinar la eficiencia de BK con la capacidad de cobertura profunda de las variantes de BY, especialmente en dominios como recuperación de documentos, detección de patrones o sistemas de recomendación.\n\n---\n\n### Tabla y Métricas\n\n* **BK** destaca como el algoritmo más eficiente globalmente:\n\n  * Promedios más bajos en tiempo y comparaciones en los tres conjuntos.\n  * Baja varianza, lo cual refleja un comportamiento consistente ante diferentes distribuciones de datos.\n  * Ideal para producción en tiempo real, gracias a su predictibilidad y rendimiento estable.\n\n* **ME** refleja limitaciones importantes:\n\n  * Sus valores medios y máximos en tiempo y comparaciones son los más altos del conjunto.\n  * Muestra fuerte dispersión, lo que indica una pobre adaptación a cambios en el volumen o estructura de las listas.\n  * No es recomendable para aplicaciones a gran escala.\n\n* **BY\\_B2** demuestra potencial cuando se dispone de datos bien distribuidos y se busca profundidad, pero sus costos extremos en algunas instancias comprometen su fiabilidad general. La alta desviación estándar lo posiciona como una opción con riesgos en entornos donde se requiere consistencia.\n\n* **BY\\_B1 y BY\\_bis** representan compromisos efectivos:\n\n  * **BY\\_B1** ofrece la mejor cobertura en intersecciones largas, especialmente en conjunto B.\n  * **BY\\_bis** logra tiempos y comparaciones reducidas cuando los conjuntos están bien balanceados.\n  * Ambos mantienen una dispersión moderada y son adecuados para aplicaciones prácticas con presupuestos computacionales limitados.\n\n---\n\n### Síntesis Final\n\nEl estudio confirma que no existe un único algoritmo óptimo para todos los escenarios, pero **BK** emerge como el candidato más versátil por su bajo costo y estabilidad. **BY\\_B1** ofrece la mejor cobertura cuando la prioridad es capturar intersecciones completas, mientras que **BY\\_bis** y **BY\\_B2** ofrecen alternativas viables según la estructura del problema. **ME**, aunque funcional, queda relegado a contextos educativos o demostrativos debido a su pobre escalabilidad.\n\n---\n\n\n# **Referencias**\n\n* Baeza-Yates, R. (2004). *Efficient Text Searching*. In: Algorithms and Applications.\n* Barbay, J., López-Ortiz, A., & Lu, T. (2006). *Faster Adaptive Set Intersections*. In: Experimental Algorithms.\n* Demaine, E. D., López-Ortiz, A., & Munro, J. I. (2001). *Adaptive Set Intersections, Unions, and Differences*. In: SODA.\n* Hwang, F. K., & Lin, S. (1971). *A linear-time algorithm for merging two sorted arrays*. In: ACM Transactions.\n* MacKay, D. J. C. (2003). *Information Theory, Inference, and Learning Algorithms*. Cambridge University Press.\n\n---\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["styles.css"],"output-file":"SegundoDavid_U5_T1.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","theme":{"light":"flatly","dark":"darkly"},"toc-location":"right","toc-title":"En esta página"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}