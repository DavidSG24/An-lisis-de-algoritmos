{"title":"**Introducción**","markdown":{"headingText":"**Introducción**","containsRefs":false,"markdown":"\n<h1><b>Reporte Escrito: Experimentos y análisis de algoritmos de ordenamiento.</b></h1>\n\n<h1><b>Alumno: David Segundo Garcia</b></h1>\n\n----\n\n\n\n\nA lo largo de las últimas décadas se han realizado múltiples estudios para evaluar y mejorar la eficiencia de los algoritmos de ordenamiento, pues esta tarea es fundamental en la computación. Por ejemplo, investigaciones tempranas (Fosdick & Cline, 1974) realizaron exhaustivas pruebas de rendimiento de diversas variantes de quicksort, demostrando que pequeños ajustes en la implementación pueden tener un impacto significativo en el número de comparaciones y en el tiempo de ejecución. Estas pruebas sentaron las bases para posteriores estudios sobre optimización y adaptabilidad de los métodos de ordenamiento.\n\nPor otro lado, el desarrollo de algoritmos adaptativos ha permitido aprovechar el orden parcial existente en los datos. Estivill-Castro y Wood (1992) destacan que los algoritmos adaptativos optimizan su desempeño en función del grado de desorden de la secuencia, lo cual es especialmente relevante para listas que se encuentran casi ordenadas. En este contexto, Cook y Kim (1980) demostraron que, para listas con una alta “sortedness”, algoritmos como el Straight Insertion Sort pueden superar a métodos más generales, mientras que para listas menos ordenadas se requieren técnicas más sofisticadas como Quickersort.\n\nFinalmente, la introducción de estructuras de datos alternativas, como las skip lists, ha ofrecido soluciones simples y eficientes para mantener el orden de los datos sin necesidad de recurrir a estructuras complejas de equilibrio estricto. Pugh (1990) propuso que, mediante el uso de un mecanismo probabilístico para asignar niveles a los nodos, las skip lists logran un rendimiento comparable al de los árboles balanceados, pero con una implementación mucho más sencilla. Esta combinación de adaptabilidad y estructuras eficientes refleja el continuo esfuerzo por mejorar los métodos de ordenamiento en diversos contextos computacionales.\n\n\n\n----\n\n## **Instrucciones**:\n\n1. **Implementa** y **compara** los siguientes algoritmos de ordenamiento:\n\n   - Heapsort\n   - Mergesort\n   - Quicksort\n   - Bubblesort\n   - La estructura de datos **SkipList** y utilízala para ordenar\n\n2. **Utiliza** los diferentes archivos proporcionados, los cuales tienen diferentes niveles de desorden y mide tanto el número de comparaciones como el tiempo necesario para ordenarlos.\n\n3. Por cada archivo de datos, **compara** todos los métodos implementados mediante figuras o tablas de datos (número de comparaciones y tiempo por separado).\n\n4. **Discute** tus resultados.\n\n----\n\n<h1><b>Solución</b></h1>\n\n## **Punto 1**\n\n\n**Implementa** y **compara** los siguientes algoritmos de ordenamiento:\n\n   - Heapsort\n   - Mergesort\n   - Quicksort\n   - Bubblesort\n   - La estructura de datos **SkipList** y utilízala para ordenar\n\n### Definimos las librerías que usaremos:\n\n### Funcíon para cargar datos en la carpeta zip\n\n### Implementamos clases para el algoritmo SkipList\n\n### Clase para implementar los algoritmos de ordenamieno\n\n### Funciones para ejecutar los algoritmos de ordenamiento y generar las gáficas.\n\n-----\n\n ## **Punto 2**\n **Utiliza** los diferentes archivos proporcionados, los cuales tienen diferentes niveles de desorden y mide tanto el número de comparaciones como el tiempo necesario para ordenarlos.\n\n### LLamadas la funciones para implementar los algoritmos a los archivos en la carpeta .zip\n\n### Tabla de Comparaciones\n\n### Tabla de Tiempos\n\n-----\n\n ## **Punto 3**\nPor cada archivo de datos, **compara** todos los métodos implementados mediante figuras o tablas de datos (número de comparaciones y tiempo por separado).\n\n\n\n\n-----\n\nPara cada uno de los archivos de datos (*perturbaciones-p=016*, *perturbaciones-p=032*, *perturbaciones-p=064*, *perturbaciones-p=128*, *perturbaciones-p=256* y *perturbaciones-p=512*), se obtuvieron dos tipos de resultados: el **número de comparaciones** y el **tiempo de ejecución** (en segundos) que cada algoritmo requirió para ordenar la lista correspondiente. En las tablas y gráficas mostradas (ver imágenes provistas), se evidencia lo siguiente:\n\n- **BubbleSort**:  \n  - Generalmente presenta la **mayor** cantidad de comparaciones en todos los archivos, lo cual coincide con su complejidad teórica $O(n^2)$.  \n  - En consecuencia, su tiempo de ejecución también tiende a ser elevado, sobre todo a medida que aumenta el tamaño y/o desorden de la lista.\n\n- **HeapSort**:  \n  - Su número de comparaciones se mantiene en un orden cercano a $O(n \\log n)$, por lo que resulta más eficiente que BubbleSort en los archivos de mayor tamaño.  \n  - En cuanto a tiempo, logra buenos resultados, aunque en algunos casos queda por detrás de QuickSort o MergeSort.\n\n- **MergeSort**:  \n  - Mantiene un comportamiento **consistente** de $O(n \\log n)$ en la mayoría de los casos, tanto en comparaciones como en tiempo.  \n  - Presenta un rendimiento estable incluso para listas muy desordenadas, pues divide el problema en sublistas y luego fusiona ordenadamente (Fosdick & Cline, 1974).\n\n- **QuickSort**:  \n  - Muestra, en general, uno de los mejores promedios de tiempo, especialmente en listas con perturbaciones medianas o grandes, confirmando su naturaleza de $O(n \\log n)$ promedio (Cook & Kim, 1980).  \n  - Sin embargo, el número de comparaciones puede variar según la selección del pivote, aunque en estos experimentos se ve favorecido en la mayoría de los archivos.\n\n- **SkipListSort** (uso de SkipList para ordenar):  \n  - El número de comparaciones y el tiempo tienden a ser **moderados**, sin llegar a ser tan alto como BubbleSort ni tan bajo como QuickSort en la mayoría de los casos.  \n  - Dado que la inserción en una SkipList es probabilística, puede ofrecer un desempeño cercano a $O(n \\log n)$ (Pugh, 1990). Sin embargo, no siempre supera a QuickSort o MergeSort, ya que depende del patrón de inserción y de la generación aleatoria de niveles (Estivill-Castro & Wood, 1992).\n\nEn términos de **comparaciones**, BubbleSort sobresale negativamente por su alto conteo, mientras que QuickSort y MergeSort tienden a destacar por su eficiencia. Heapsort y SkipListSort se ubican en posiciones intermedias. Respecto al **tiempo de ejecución**, la tendencia es similar: BubbleSort es el más lento, QuickSort y MergeSort suelen ser los más rápidos, y Heapsort/SkipListSort mantienen un rendimiento aceptable en la mayoría de los casos.\n\n---\n\n\n\n\n## **Punto 4**\n **Discute** tus resultados.\n\n-----\n\nLos resultados experimentales confirman las **características teóricas** de cada algoritmo:\n\n- **BubbleSort**, con complejidad $O(n^2)$, es poco recomendable para listas de gran tamaño o con alto desorden, ya que demanda un gran número de comparaciones y mayor tiempo de CPU.\n- **MergeSort** y **QuickSort** validan su eficiencia de $O(n \\log n)$. QuickSort, en particular, suele ser muy rápido para datos aleatorios o con cierto desorden, aunque en casos adversos (pivotes desfavorables) podría aumentar sus comparaciones. MergeSort, por su parte, ofrece un rendimiento constante al dividir y fusionar.\n- **HeapSort** mantiene un comportamiento estable y eficiente en comparaciones y tiempo; sin embargo, no siempre alcanza los mejores resultados frente a QuickSort o MergeSort.\n- **SkipListSort** se beneficia del uso probabilístico de niveles (Pugh, 1990). En la práctica, su rendimiento puede ser cercano al de los algoritmos $O(n \\log n)$, pero la sobrecarga en la construcción y administración de la estructura puede hacerlo menos competitivo que QuickSort o MergeSort para algunos tamaños de lista.\n\nEn consonancia con estudios previos (Cook & Kim, 1980; Estivill-Castro & Wood, 1992), se observa que **ningún algoritmo es el “mejor” en todos los escenarios**. La elección depende tanto del tamaño de la lista como de su nivel de desorden. QuickSort y MergeSort suelen ser opciones sólidas para un rango amplio de situaciones. Si se sabe de antemano que las listas están casi ordenadas, algoritmos como InsertionSort o estructuras adaptativas (SkipLists) podrían tener un rendimiento aceptable, aunque en estos experimentos la comparación global muestra que QuickSort y MergeSort mantienen un balance más favorable en la mayoría de los casos.\n\n---\n\n\n## **Referencias**\n\n- Cook, C. R., & Kim, D. J. (1980). Best sorting algorithm for nearly sorted lists. *Communications of the ACM, 23*(11), 620–628.  \n- Estivill-Castro, V., & Wood, D. (1992). A survey of adaptive sorting algorithms. *ACM Computing Surveys, 24*(4), 441–476.  \n- Fosdick, L. D., & Cline, A. K. (Eds.). (1974). *Some performance tests of “quicksort” and descendants*. Smithsonian Astrophysical Observatory.  \n- Pugh, W. (1990). Skip lists: A probabilistic alternative to balanced trees. *Communications of the ACM, 33*(6), 668–676.\n\n---\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["styles.css"],"output-file":"SegundoDavid_U3_T1.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","theme":{"light":"flatly","dark":"darkly"},"toc-location":"right","toc-title":"En esta página"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}